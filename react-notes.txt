React notes: 24-10-2022 => => 16-12-2022 => 07-03-2023
-----------------------
React official websites:-
https://reactjs.org/
https://beta.reactjs.org/

1. Install node js.
	Node is required to run the angular/react/vue.js. Download the latest node.js from the below link.
	https://nodejs.org/en/download/

https://nodejs.org/dist/v18.12.1/node-v18.12.1-x64.msi

2. Check the node version. Using the below commands we can check the node and npm versions.
	node -v
	npm -v

3. Create a new project.
	npx create-react-app projectName
	npx create-react-app payroll
	npx create-react-app my-app --template typescript

Start the project using the below command.
Note:- Make sure that you are running the below command from project folder.
	npm start

All commands together:-
	npx create-react-app my-app
	cd my-app
	npm start

Then open http://localhost:3000/ to see your app.

Here: localhost is our machine address
3000 => port number.

Creating a TypeScript app
You can start a new TypeScript app using templates. To use our provided TypeScript template, append --template typescript to the creation command.
	npx create-react-app my-app --template typescript


Project files:-
--------------
Whenever we are creating the react project, below files will be generated.
my-app => project name
├── README.md
├── node_modules
├── package.json
├── .gitignore
├── public
│   ├── favicon.ico
│   ├── index.html
│   ├── logo192.png
│   ├── logo512.png
│   ├── manifest.json
│   └── robots.txt
└── src
    ├── App.css
    ├── App.js
    ├── App.test.js
    ├── index.css
    ├── index.js
    ├── logo.svg
    ├── serviceWorker.js
    └── setupTests.js

node_module
	- This folder contains the all libraries required for the project.
	- This folder is auto generated.
	- run the 'npm install' command to generate the node_module folder

index.html
	- React will load the index.html file first.
	- It will contain the root div tag.

manifest.json
	- The web app manifest provides information about an application (such as name, author, icon, and description) in a JSON text file. The purpose of the manifest is to install web applications to the homescreen of a device, providing users with quicker access and a richer experience.

robots.txt
	- Robots.txt file is a text file created by the designer/developer to prevent the search engines and bots to crawl up their sites. It contains the list of allowed and disallowed sites and whenever a bot wants to access the website, it checks the robots.txt file and accesses only those sites that are allowed. It doesn’t show up the disallowed sites in search results.

src
	- All source code will be placed inside the src folder.

.gitignore
	- Ignore the list of files from git.

package.json
	- It will have list of library information used in the project.

Scripts:-
--------
npm start
	- To start the project.

npm test
	- To test the unit test cases.

npm run build
	- Builds the app for production to the build folder. It correctly bundles React in production mode and optimizes the build for the best performance.

React:-
------
- React is a JavaScript library for building user interfaces/web pages.
- React is used to build single-page applications.
- React is Component-Based library. We can implement component once and reuse the that in entire project.
- React works based on the virtual DOM. React maintains the state in virtual DOM and compares with the previous Virtual DOM state. It will apply the differences to the real DOM. => Reconciliation
- React allows us to create reusable UI components.

- DOM: Document Object Model.


What is SPA?
-----------
SPA means Single page application (SPA)
SPA is a single page where a lot of information stays the same and only data will be updated into particular place.
For example, when we load our site, the sidebar and header remain same and only body changes based on navigation.
If it is normal html, then whole page will be reloaded.
- It will improve performance and user experience.

How does React Work?
-------------------
- React creates a VIRTUAL DOM in memory.
- Instead of manipulating the browser's DOM directly, React creates a virtual DOM in memory, where it does all the necessary manipulating, before making the changes in the browser DOM.
- React only changes what needs to be changed!

What is reconciliation in react?
A virtual DOM is a lightweight JavaScript object which originally is just a copy of the real DOM. It is a node tree that lists the elements, their attributes and content as Objects and their properties.
React works based on the virtual DOM. React maintains the state in virtual DOM and compares with the previous Virtual DOM state. It will apply the differences to the real DOM. This process is called reconciliation.
The mechanism to diff one tree with another to determine which parts need to be changed and then update the original DOM with it is called Reconciliation .
ReactJS uses a new reconciliation engine called Fiber since version 16.0

Versions:-
---------
Current version of React.JS is V18.0.0 (April 2022).
Initial Release to the Public (V0.3.0) was in July 2013.
React.JS was first used in 2011 for Facebook's Newsfeed feature.


React renders HTML to the web page by using a function called ReactDOM.render()
The ReactDOM.render() function takes two arguments, HTML code and an HTML element.

The purpose of the function is to display the specified HTML code inside the specified HTML element.

ReactDOM.render(<p>Hello</p>, document.getElementById('root'));

React flow:-
----------
React will load the index.html first. As part of the index.html file, we have the below tag
	 <div id="root"></div>

- Index.js will be executed after that.
- As part of the index.js, ReactDOM renders the components.

- React and ReactDOM classes are imported from the react libraries.
- render method used to render the output.
---------------------------------------
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
---------------------------------------
- As part of the render method, it loads the App component. So App component will be displayed initially.


- component types
- functio based
- class based.

- adding bootstrap by link approch.
- adding bootstrap by npm approch.

- import styles in js
- jsx
- 

Component:-
----------
- A component is a function/class which will display something to the user.
- We can write component once and reuse the entire project.
- It helps to avoid the duplicate code.
- A component may have css and js files.
- Component name must be Written using camel case and starts with the capital as shown below.
- Components come in two types, Class components and Function components.
1. function based components
2. class based components

Note:-
In older React code bases, you may find Class components primarily used. function components are introduced from React 16.8 2019
---------function based-------------------------------
function App() {
	return (
		<div>
			Hello world
		</div>
	)
}

export default App.
----------------------------------------

Class based components:-
---------------------
- When the state object changes, the component re-renders.
- Refer to the state object anywhere in the component by using the this.state.propertyname syntax:

---------class based------------------
class App extends React.Component {
   constructor(props) {
    super(props);
    this.state = {color: "red"};
  }

  static getDerivedStateFromProps(props, state) {
    return {favoritecolor: props.favcol };
  }

  render() {
    return <div>
			Hello world {this.state.color} {this.props.model}
		</div>
  }

  componentDidMount() {
    setTimeout(() => {
      this.setState({favoritecolor: "yellow"})
    }, 1000)
  }


}
---------------------------------------
What is JSX?
JSX is a shorthand for JavaScript XML. This makes the HTML file really easy to understand.
This is a type of file used by React which utilizes the expressiveness of JavaScript along with HTML like template syntax.
This file makes applications robust and boosts its performance.
Web browsers cannot read JSX directly. This is because they are built to only read regular JS objects and JSX is not a regular JavaScript object For a web browser to read a JSX file, the file needs to be transformed into a regular JavaScript object. For this, we use Babel

JSX:-
- Component uses the JSX syntax.
- JSX means syntax extension to JavaScrip.
- JSX produces React “elements”.
- JSX allows us to write HTML elements in JavaScript and place them in the DOM without any createElement()  and/or appendChild() methods.
- JSX converts HTML tags into react elements.

- As part of the JSX syntax, we can't use 2 tags at high level.
- If we want to use then we have use those code in side the empty <></>

Fragment:-
--------
- In React, a fragment is a way to group multiple elements together without adding an extra node to the DOM. A fragment is represented by the <React.Fragment> component or the shorthand syntax <>. Here's an example of using fragments to return multiple elements from a component:
<></>
----------------------------------------
function App() {
	return (
		<>
			<div>
				Hello world
			</div>
		</>
	)
}
----------------------------------------
- Create the dynamic content

const myElement = React.createElement('h1', {}, 'I do not use JSX!');
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(myElement);
----------------------------------------

With JSX you can write expressions inside curly braces { }.

The expression can be a React variable, or property, or any other valid JavaScript expression. JSX will execute the expression and return the result:

const myElement = <h1>React is {5 + 5} times better with JSX</h1>;

- print any variable.
{age}
{p.age}

- Call any function.
{test()}

- The class attribute is a much used attribute in HTML, but since JSX is rendered as JavaScript, and the class keyword is a reserved word in JavaScript, you are not allowed to use it in JSX.


You may use quotes to specify string literals as attributes:
<a href="https://www.reactjs.org"> link </a>;

You may also use curly braces to embed a JavaScript expression in an attribute:
<img src={user.avatarUrl}></img>;

Note:- Don’t put quotes around curly braces when embedding a JavaScript expression in an attribute.

How to print the const or object values in the JSX?
- We can print any value in the JSX using the {} curly braces.

- We can put any valid JavaScript expression inside the curly braces in JSX.
{ 2 +2 }
{person.firstName }

- In JSX expression code, we can call any method.
{ formatName(user) }

--------------------------------------
const name = "Trinits Technlogies";
const person = {
	name: "SS",
	age: 30
}

<div>{name}</div>
<div>{person}</div>	==> This line will give compilation issues, we should not directly print the object like this.
<div>{person.name}</div>
<div>{person.age}</div>
--------------------------------------

How to import css to the component?
- using the import statement we can use css. But If we import css as show below, then these styles are applicable to entire project. These styles may overlap with the other component styles.
--------------------------------------
	import './App.css'
--------------------------------------

How to apply CSS styles for a single component?
- To apply the css to a single component, we have to create the style file with the "*.module.css".
- Eg: for instead 'AppHeader.css', we have to create 'AppHeader.module.css' file.
- We have to apply the css using the object way like {classes.header}.
Note:- Don't write the code like className="{classes.header}" or className="classes.header"

- CSS module can be used with Pure CSS or with Sass. The naming convention for CSS module is a specific name followed by dot and module(test.module.css or test.module.scss)
--------------------------------------
import classes from './AppHeader.module.css'

function AppHeader() {
	return (
		<>
			<div className={classes.header}>
				Hello world
			</div>
		</>
	)
}

<input className={`base-input-class ${classes.header}`}>
<li className={[activeClass, data.class, "main-class"].join(' ')} />
<div className={style.style1+ ' ' + style.style2} />



Writing the inline styles.

style={{
        backgroundColor: 'red',
        color: 'green',
        fontSize: '14px'
    }}
--------------------------------------

How to import the Bootstrap to the project?
Solution 1:-
- Add the below CDN links to the index.html file.
---------------------------------------------------------
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
	<!-- JavaScript Bundle with Popper -->
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
---------------------------------------------------------

Solution 2:-
- Install the Bootstrap to the project using the npm command
	npm install bootstrap
	npm i bootstrap
	npm install --save bootstrap

- Import bootstrap files in App component.
import '../node_modules/bootstrap/dist/css/bootstrap.min.css';


React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.

Event handling:-
---------------
- In react event handling is similar to the html events.
- Mainly 2 parts.
	1. event name in the camel case. Eg: onClick event.
	2. Assign the function to the click event. Write function name in the curly braces.
		- Instead of writing a new function, we can use es6 function also.

What is bubbling/event bubbling in react?
What is bubbling in programming? Event bubbling is a type of DOM event propagation where the event first triggers on the child element, and then propagated to the parent of the target
Event will be propagated till it reaches the outermost DOM element or document object
For an example an anchor inside button. If we handles the click action on button, but use clicks on the anchor tag, first event raised at anchor tag(child level) and propagates to parent button.


What are SyntheticEvent in React native?
React has its own event handling system which is very similar to handling events on DOM elements. The react event handling system is known as Synthetic Events. The synthetic event is a cross-browser wrapper of the browser's native event
React synthetic events are very similar to native events, however, with synthetic events, the same API interface is implemented across multiple browsers.
Handling events with react have some syntactic differences from handling events on DOM. These are:
1. React events are named as camelCase instead of lowercase.
<button onclick="showMessage()"> Hello React </button


2. With JSX, a function is passed as the event handler instead of a string. For example:
<button onClick={showMessage}> Hello React </button>


3. 3. In react, we cannot return false to prevent the default behavior. We must call preventDefault event explicitly to prevent the default behavior. For example:
<a href="" onClick={(e) => {e.preventDefault()}}> Hello React </a>


---------------------------------------------------
function onClickHandler(){
	console.log('Event handled');
}

<button onClick={onClickHandler}>Test</button>
<button onClick={() => {onClickHandler()}>Alert me</button>
---------------------------------------------------

Passing Arguments to method
-----------------------------
- To pass an argument to an event handler, use an arrow function.

 <button onClick={() => shoot("Goal!")}>Take the shot!</button>
-------------------------------------------------------------------

Property binding:-
----------------
- Binding variable to html element is called property binding.
<input value={username} />

- React support only 1 way binding. unidirectional binding.


Form way property binding
----------------------
- In react there is no direct way of providing the 2 way binding.
- To achieve 2 way binding, we have to combine the property binding, event handling and useState mechanism.
---------------------------------------
//1. Create a Tuple using useState hook
const [username, setUsername] = useState('');

//2. Write a function to update the username field value to state.
function onClickHandler(event){
	setUsername(event.target.value);
}

//3. In the input container use event and property binding.
<input onChange={onClickHandler} value={username}/>


Form validations also.
---------------------------------------


Parent to child data:-
--------------------
- In React, we can pass to data to child using the "props" property.
- From parent tag, we can pass all the values in the tag directly, so these values will be bind to the props object.
- In the child tag, we can get the data from "props" argument.

React Props:-
- Props are arguments passed into React components.
- Props are passed to components via HTML attributes.

What is Props?
- Props is the shorthand for Properties in React. They are read-only components which must be kept pure i.e. immutable.
- They are always passed down from the parent to the child components throughout the application.
A child component can never send a prop back to the parent component.
- This help in maintaining the unidirectional data flow and are generally used to render the dynamically generated data.

In React, props are designed to be read-only, which means that a child component cannot change the value of a prop that is passed down from its parent. This is by design to maintain a one-way data flow between components and make the application more predictable and easier to reason about.

Note: React Props are read-only! You will get an error if you try to change their value.

Props can contain any type of data, such as strings, numbers, arrays, objects, or even functions. They are typically used to configure or customize a child component's behavior, appearance, or content based on the data passed down from the parent component.

When the parent's state or props change, React will automatically re-render the parent and all of its children components that depend on the changed data.

When a component is re-rendered, React compares the new props with the previous props to determine if the component needs to update its content. If the new props are different from the previous props, React will re-render the component and update its content with the new data. If the new props are the same as the previous props, React will skip the re-rendering process to optimize performance.

To pass props from a parent component to a child component, you simply include the props as attributes when you render the child component. 
-----------------------------------------
const student = {};

//Parent component
function StudentInfo() {
  return <div>
		<StudentForm studentData={student}/>
	</div>;
}

//Child component
function StudentForm(props) {
  return <div>
		{JSON.stringify(props.studentData)}
	</div>;
}

//Or we can use extract the data from props object as show below using destructuring.
//Child component
function StudentForm({studentData}) {
  return <div>
		{JSON.stringify(studentData)}
	</div>;
}
-----------------------------------------

Child to parent data:-
--------------------
- Passing data from child to parent also using the props.
- In child component props, we can add a new property for handling the buttons. Eg: addStudent to the props.
- In the parent component, write a function 'addStudentHandler' and pass this function to child

-----------------------------------------
const student = {};
function addStudentHandler() {
	//Write the student to the array.
}

//Parent component
function StudentInfo() {
  return <div>
		<StudentForm studentData={student} addStudent={addStudentHandler}/>
	</div>;
}

//Child component
function StudentForm(props) {
  return <div>
		<button onClick={props.addStudent}>Add</button>
	</div>;
}

//Or we can use extract the data from props object as show below
//Child component
function StudentForm({studentData, addStudent}) {
  return <div>
		{JSON.stringify(studentData)}
		<button onClick={addStudent}>Add</button>
	</div>;
}
-----------------------------------------

Containment:-
------------
- Printing all child html to parent using the containment process.

In React, containment is a technique where a component can receive other components as children and render them inside its own output. This allows for composing components and creating complex UI structures from smaller, reusable building blocks.

To enable containment in a React component, you can use the special children prop that is automatically passed to every component. This prop represents the content that is passed between the opening and closing tags of a component, like this:

In the below example, the ParentComponent receives a title prop and a children prop, and renders them inside a div element. The ChildComponent is passed as a child component inside the ParentComponent. The ChildComponent receives a text prop and renders it inside a p element.

When the App component is rendered, it will render the ParentComponent with the title prop set to "My Parent Component", and the ChildComponent passed as a child component. The ChildComponent will be rendered inside the ParentComponent, in the place where the children prop is used.

Using containment, you can create flexible, reusable components that can be used in different contexts, and can render different content depending on their children.
----------------------------------------------
function ParentComponent(props) {
  return (
    <div>
      <h1>{props.title}</h1>
      <div>{props.children}</div>
    </div>
  );
}

function ChildComponent(props) {
  return <p>{props.text}</p>;
}

function App() {
  return (
    <ParentComponent title="My Parent Component">
      <ChildComponent text="This is my child component" />
    </ParentComponent>
  );
}

--------------------------------------------

React.memo:-
-----------
- React.memo is used to memoize function components and optimize re-renders. 
- React.memo is a higher-order component that can wrap a functional component and memoize its result based on the equality of the props. If the props are the same as the previous render, the component will not re-render.

Here's an example of using React.memo to memoize a functional component:

import React from 'react';

function MyComponent(props) {
  return <div>{props.someProp}</div>;
}

export default React.memo(MyComponent);
--------------------------------------

In this example, MyComponent is wrapped in React.memo, which will compare the someProp prop of the new render with the previous render, and only re-render if it has changed.

useMemo:-
--------
useMemo is a hook that allows you to optimize expensive computations by memoizing their results. It takes two arguments: a function that performs the computation, and an array of dependencies. The hook will recompute the value only when one of the dependencies has changed. Here's an example:

import React, { useMemo } from 'react';

function MyComponent(props) {
  const result = useMemo(() => {
    // Perform an expensive computation
    return computeResult(props.data);
  }, [props.data]);

  return <div>{result}</div>;
}

In this example, the useMemo hook memoizes the result of the computeResult function, and re-computes it only when the props.data dependency changes. This can improve performance by avoiding unnecessary recomputations of the result.


Another way to achieve the same result is by using the useMemo hook. useMemo allows you to memoize the result of a function based on its dependencies. If the dependencies have not changed, the memoized result is returned, otherwise the function is re-evaluated.

Here's an example of using useMemo to memoize a function that returns a JSX element:

import React, { useMemo } from 'react';

function MyComponent(props) {
  const memoizedElement = useMemo(() => {
    return <div>{props.someProp}</div>;
  }, [props.someProp]);

  return memoizedElement;
}

export default MyComponent;
----------------------------------------
In this example, useMemo is used to memoize the result of the function that returns a JSX element based on the someProp prop. If someProp has not changed, the memoized element is returned, otherwise the function is re-evaluated.

Routing:-
--------
- Routing is an important aspect of building a single-page application (SPA) in React. It allows you to navigate between different pages or views within the application, without triggering a full page refresh.
- If we want navigate from page to another page, we have to use the routing technique.
- React app is SPA application so using anchor tags(<a>) will reload the entire application hence data will be lost. State can't maintain the data on reload the page.
- In React, for routing we can the routing libraries like react-router-dom.
- Follow the below steps to add the routing the app.

1. Install the routing library using below command.
	npm install --save react-router-dom@5

2. Import BrowserRouter in the index.js file.

-----------------------------
import { BrowserRouter } from 'react-router-dom';

<BrowserRouter>
      <App />
</BrowserRouter>
-------------------------------

3. Create the routing the App.js
- Create the route for each component
- Switch component will make sure that, at a time only one router is active.
-
-----------------------------------------
	<Switch>
	  <Route path="/" exact>
		<Home />
	  </Route>

	  <Route path="/student" exact>
		<StudentInfo />
	  </Route>

	  <Route path="/organization" exact>
		<OrganizationInfo />
	  </Route>

	  <Route path="/employee" exact>
		<EmployeeInfo />
	  </Route>

	  <Route path="/login" exact>
		<Login />
	  </Route>
	  
	  <Route path="/users/:userId" component={User} />
	  
	</Switch>
-----------------------------------------

4. Add the links using the Link tag from react dom.
<Link to='/login'>Login</Link>

5. For the dynamic routes, In the route configuration, we have declare as shown below.
<Route path="/users/:userId" component={User} />

In the component, if we have fetch the dynamic id,we can get it from props.
const userId = props.match.params.userId;
---------------------------------
function User(props) {
  const userId = props.match.params.userId;
  
  // Use the userId to fetch user data and render it
  
  const location = useLocation();
  const queryParams = new URLSearchParams(location.search);
  const name = queryParams.get('name');


  return (
    <div>
      <h1>User {userId}</h1>
      // render user details
    </div>
  );
}
------------------------------------------
In the above example, the third route has a parameter :userId in its path. This means that the path will match any URL that has /users/ followed by a dynamic value. The value will be available in the match.params object of the User component.

You can then use this parameter to fetch the corresponding user data and render it in the component.


How to define the component if path is not matching?
In React Router Dom, if you want to define a path for components that do not match any of the other defined routes, you can use the <Route> component with no specified path prop and with the component prop set to the component you want to render.


It's worth noting that when using the * path, it's important to place it as the last route in the Switch component, as it will match any path that comes after it, even if it would match a more specific route earlier in the list.

Here's an example:
-----------------------------------------------------
import { Route, Switch } from 'react-router-dom';
import Home from './Home';
import About from './About';
import NotFound from './NotFound';

function App() {
  return (
    <div>
      <Switch>
        <Route exact path="/" component={Home} />
        <Route path="/about" component={About} />
        <Route component={NotFound} />
		//<Route path="*" component={NotFound} />
      </Switch>
    </div>
  );
}
---------------------------------------------------------
In the above example, the Switch component is used to render only the first matching route. The first two routes have specific paths defined, while the third route does not. This means that if the user enters a URL that does not match any of the defined paths, the NotFound component will be rendered.



For more information, please follow the below link
https://reactrouter.com/en/main
https://reactrouter.com/en/main/start/tutorial


useHistory()
- useHistory hook is used for navigation purpose.
- This hook is available from react-router-dom package.

useHistory is a hook provided by React Router Dom that allows you to access and manipulate the browser's history stack. You can use this hook to navigate between pages in your application, either by pushing new entries onto the stack or replacing the current entry with a new one.

Here's an example of how to use useHistory to navigate to a new page:
----------------------------------
import { useHistory } from 'react-router-dom';

function MyComponent() {
  const history = useHistory();

  function handleClick() {
    history.push('/new-page');
    //history.replace('');
  }

  return (
    <div>
      <button onClick={handleClick}>Go to new page</button>
    </div>
  );
}
----------------------------------
In the above example, useHistory is called to get access to the history object. The push() method of this object is then called when the button is clicked, which adds a new entry to the browser's history stack and navigates the user to the /new-page URL.

You can also use the replace() method of the history object to replace the current entry in the stack with a new one, instead of adding a new entry. Additionally, you can use the goBack() and goForward() methods to navigate to the previous or next entry in the stack, respectively.

Note that it's important to only use push() or replace() to navigate within your application, rather than directly manipulating the window.location object. This ensures that the React Router Dom library is properly notified of any changes to the URL, which allows it to properly update the component tree and render the correct components for the new URL.


useLocation:-
-----------
To retrieve query parameter values in React Router Dom, you can use the useLocation hook provided by the library. The useLocation hook returns an object with information about the current URL, including the query parameters.

Here's an example of how to use useLocation to retrieve the value of a query parameter:

import { useLocation } from 'react-router-dom';

function MyComponent() {
  const location = useLocation();
  const queryParams = new URLSearchParams(location.search);
  const myParam = queryParams.get('myParam');

  return (
    <div>
      <p>Query parameter value: {myParam}</p>
    </div>
  );
}
In the above example, useLocation is called to get information about the current URL. The search property of the location object contains the query parameters as a string, which can be converted into a URLSearchParams object. You can then use the get() method of this object to retrieve the value of a specific query parameter.

In this case, we retrieve the value of a query parameter called myParam and render it in the component. Note that the get() method returns null if the query parameter does not exist, so you may want to include some additional logic to handle this case.


Conditional statements:-
-----------------------
Conditional statements are a fundamental part of programming in React. They allow you to conditionally render UI elements based on the state of your application.

In React, conditional statements can be written using JavaScript's conditional (ternary) operator, if-else statements, or switch statements.

Using Ternary operator
The ternary operator is a concise way to write if-else statements. It takes three operands: a condition, a statement to execute if the condition is true, and a statement to execute if the condition is false.

Here's an example of using the ternary operator to conditionally render a component based on a boolean value:

-------------------------------------
function App() {
  const isLoggedIn = true;
  return (
    <div>
      {isLoggedIn ? <p>Welcome back!</p> : <p>Please log in.</p>}
	  {isLoggedIn
        ? <LogoutButton onClick={this.handleLogoutClick} />
        : <LoginButton onClick={this.handleLoginClick} />
      }

    </div>
  );
}
-----------------------------------

Using if-else statements
If-else statements can be used to write more complex conditional logic in your React components. Here's an example of using an if-else statement to conditionally render a component based on multiple conditions:

----------------------------------------
function App() {
  const isLoggedIn = true;
  const isAdmin = true;
  if (isLoggedIn && isAdmin) {
    return <p>Welcome back, admin!</p>;
  } else if (isLoggedIn) {
    return <p>Welcome back!</p>;
  } else {
    return <p>Please log in.</p>;
  }
}
--------------------------------------


Using && operator for only for the if conditions.
In the below example it shows the username only if user is logged in.
-------------------------------------
function App() {
  const isLoggedIn = true;
  return (
    <div>
      {isLoggedIn && <p>{username}</p>}
    </div>
  );
}
-----------------------------------

Loader:-
---------------
A loader is a common UI element used in React to indicate that content is loading or processing. There are many ways to implement a loader in React, but one of the most common is to use conditional rendering and CSS to display a spinner or progress bar.

Here's an example of how you can implement a loader in React using conditional rendering and CSS:

-------------------------------------------------
import React, { useState, useEffect } from "react";
import "./loader.css"; // Import the CSS for the loader

function Loader() {
  return (
    <div className="loader-container">
      <div className="loader"></div>
    </div>
  );
}

function MyComponent() {
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Simulate loading time with a setTimeout
    setTimeout(() => {
      setIsLoading(false);
    }, 2000);
  }, []);

  if (isLoading) {
    return <Loader />;
  }

  return (
    <div>
      <h1>My Component</h1>
      <p>This is my component content.</p>
    </div>
  );
}

export default MyComponent;
---------------------------------------------
In this example, we first create a Loader component that renders a spinning loader using CSS.

We then create a MyComponent component that has a isLoading state set to true by default. We use the useEffect hook to simulate a loading time with a setTimeout function that sets the isLoading state to false after 2 seconds.

In the render method of MyComponent, we conditionally render the Loader component if isLoading is true. Otherwise, we render the content of MyComponent.

Finally, we export MyComponent so it can be used in other parts of our application.

You can customize the CSS of the loader to fit the style of your application, or you can use a pre-made CSS library such as React Spinners to quickly add a loader to your project.


Iterating array in React
---------------------
In React, lists can be created using an array of data and the map() method. The map() method is called on the array and takes a function as an argument. This function is called for each element of the array and returns a new array of React elements.


Keys:-
- Keys help React identify which items have changed, are added, or are removed.

In React, when we use the map() method to iterate over an array and create a list of elements, we should include a key prop on each element. The key prop is used by React to identify each element and track its changes in the virtual DOM. The key prop should be unique and constant for each element in the list.

When we render a list of elements without providing a key prop, React will use the index of the element in the array as the key by default. However, using the index as the key can cause issues if the order of the list changes or if elements are added or removed. This can lead to unnecessary re-renders and slow down the performance of the application.

By providing a unique and constant key prop for each element, React can efficiently update the DOM when the list changes without re-rendering all of the elements.

What are react keys?
A “key” is a special string attribute you need to include when creating lists of elements in React.
Keys are used in React to identify which items in the list are changed, updated, or deleted.
const numbers = [ 1, 2, 3, 4, 5 ];
const updatedNums = numbers.map((number)=>{
return <li key={index}>{number} </li>;
});
--------------------------------
const listItems = numbers.map((number) =>
    <li key={number.toString()}>{number}</li>
  );
  return (
    <ul>{listItems}</ul>
  );
--------------------------------
Example of iterating the posts using the fetch API.


----------------------------------
import React, { useState, useEffect } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then(response => response.json())
      .then(data => setUsers(data))
      .catch(error => console.log(error));
  }, []);

  const userList = users.map((user, index) => {
    return (
      <li key={user.id}>
        {user.name} ({user.email})
      </li>
    );
  });

  return (
    <div>
      <h1>User List</h1>
      <ul>
        {userList}
      </ul>
    </div>
  );
}

export default UserList;
-------------------------

In this example, we are using the useState and useEffect hooks to manage state and fetch the data respectively. We initialize the users state to an empty array and use the useEffect hook to fetch the data from the JSONPlaceholder API when the component mounts.

Once we have the data, we use the map() method to iterate over it and create an array of <li> elements, which we store in the userList variable.

Finally, we render the list of elements within a <ul> element, along with a heading to indicate what the list is for.

Note that we have wrapped the returned JSX in a <div> element. This is because a React component must have a single root element, and in this case we are returning two elements (<h1> and <ul>).
----------------------------------------------
https://github.com/academind/react-complete-guide-code/tree/zz-reactjs-summary/extra-files

Forms:-
------
- Forms can be handled by 2 ways.
1. Controlled way
2. Uncontrolled way

Controlled way:-
------------------
In React, a controlled component is a form element whose value is controlled by React state. This means that every time the user types something into a form input, the state is updated with the new value and the component is re-rendered with the new value.

Using controlled components in React ensures that the form data is always in sync with the state, and allows us to add validation and other custom logic to the form.

- using useState() hook and onChange() events , we can implement controlled way.

1. Create one useState hook for each input control.
	const [firstName, setFirstName] = useState('');

2. Assign the variable value to the input using "value" property.
- Handle the onChange event for the input and assign the latest value to input using the setter method.
	<input value={firstName} onChange={onFirstNameHandler}/>

- firstName always will have latest value since it binds with the HTML change event.


It imports useState from the React library and uses it to declare three state variables: username, password, and errors.

There are three functions: handleUsername, handlePassword, and handleSubmitForm which are used to handle the events of changing the input fields of the form and submitting the form.

The handleUsername function is called when the onChange event is triggered on the username input field. It sets the value of the username state variable to the value of the input field.

The handlePassword function is called when the onChange event is triggered on the password input field. It sets the value of the password state variable to the value of the input field.

The handleSubmitForm function is called when the onSubmit event is triggered on the form. It prevents the default behavior of the form, and then calls the validate function to validate the form data.

The validate function checks whether the username and password fields are filled in or not, and sets the errors object accordingly. If there are no errors, it checks whether the entered username and password are correct or not. If they are correct, an alert message is shown indicating a successful login.

The return statement contains the JSX code that defines the login form. It has two input fields for username and password, and a button to submit the form. It also has a link to the registration page.

Conditional rendering is used to display error messages if there are any errors in the username and password fields.
-----------------------------------------------------
import { useState } from "react";
import { Link } from "react-router-dom";

function Login() {
  const [username, setUsername] = useState("")
  const [password, setPassword] = useState("")
  const [errors, setErrors] = useState({});

  function handleUsername(event) {
    setUsername(event.target.value);
  }

  function handlePassword(event) {
    setPassword(event.target.value);
  }

  function handleSubmitForm(event){
    event.preventDefault();

    let errors = validate();
    let errorProps = Object.keys(errors);

    if(!errorProps.length){
      if(username == 'admin' && password == 'admin'){
        alert("success");
      }
    }

  }

  function validate(){
    let errorsObj = {};

    if(!username || !username.trim()){
      errorsObj.username = "Username is required";
    }else if(username.trim().length < 5){
      errorsObj.username = "Username is min 5 characters required.";
    }

    if(!password | !password.trim()){
      errorsObj.password =  "Password is required";
    }


    setErrors(errorsObj)
    return errorsObj;
  }

  return (
    <div>
      <div className="w-50 p-2 shadow m-auto mt-4">
        <form className="" onSubmit={handleSubmitForm}>
          <div className="mt-2">
            Username:
            <input className="form-control" value={username}  onChange={handleUsername}/>
          </div>
          {
            errors.username &&  <div>
            <small className="text-danger">{errors.username}</small>
          </div>
          }

          <div className="mt-2">
            Password:
            <input className="form-control" value={password} onChange={handlePassword}/>
          </div>
          {
            errors.password &&  <div>
            <small className="text-danger">{errors.password}</small>
          </div>
          }


          <div className="mt-2">
            <button className="btn btn-primary">Login</button>

            <Link to="/registration">Registration</Link>
          </div>
        </form>
      </div>
    </div>
  );
}

export default Login;

-----------------------------------------------------

Uncontrolled way:-
------------------
In React, an uncontrolled component is a form element whose value is not controlled by React but rather by the DOM. This means that the state of the component is managed by the DOM itself rather than React. 

Uncontrolled components are generally easier to implement and require less code, but they can be more error-prone as they rely on the DOM to maintain state.

- using useRef() hook, we can implement uncontrolled way.

Example for Uncontrolled way. useRef() hook will be used to handle the form elements.
1. Create one useRef hook for each input control.
	const firstNameRef = useRef();

2. Assign the reference variable to the input using "ref" property.
	<input ref={firstNameRef} />

3. To get the value from the reference object, we can get from the current property as shown below.
	const firstName = firstNameRef.current.value;
	
	
In this example, we are using the useRef hook to get a reference to the username and password input fields. When the form is submitted, we get the values of these input fields directly from the DOM using the value property and create a form data object. The form data object is then logged to the console.

Note that we are not using any state variables to manage the state of the form fields. Instead, the DOM is responsible for maintaining the state of these fields.
--------------------------------------
import { useRef, useState } from "react";
import { Link } from "react-router-dom";

function Login() {
  const usernameCtl = useRef("");
  const passwordCtl = useRef("");

  const [errors, setErrors] = useState({});

  function handleSubmitForm(event) {
    event.preventDefault();

    let username = usernameCtl.current.value;
    let password = passwordCtl.current.value;

    let errors = validate();
    let errorProps = Object.keys(errors);

    if (!errorProps.length) {
      if (username == "admin" && password == "admin") {
        alert("success");
      }
    }
  }

  function validate() {
    let errorsObj = {};
    let username = usernameCtl.current.value;
    let password = passwordCtl.current.value;

    if (!username || !username.trim()) {
      errorsObj.username = "Username is required";
    } else if (username.trim().length < 5) {
      errorsObj.username = "Username is min 5 characters required.";
    }

    if (!password | !password.trim()) {
      errorsObj.password = "Password is required";
    }

    setErrors(errorsObj);
    return errorsObj;
  }

  return (
    <div>
      <div className="w-50 p-2 shadow m-auto mt-4">
        <form className="" onSubmit={handleSubmitForm}>
          <div className="mt-2">
            Username:
            <input className="form-control" ref={usernameCtl} />
          </div>
          {errors.username && (
            <div>
              <small className="text-danger">{errors.username}</small>
            </div>
          )}

          <div className="mt-2">
            Password:
            <input className="form-control" ref={passwordCtl} />
          </div>
          {errors.password && (
            <div>
              <small className="text-danger">{errors.password}</small>
            </div>
          )}

          <div className="mt-2">
            <button className="btn btn-primary">Login</button>

            <Link to="/registration">Registration</Link>
          </div>
        </form>
      </div>
    </div>
  );
}

export default Login;

--------------------------------------

useRef:-
-------
In React, the useRef hook is used to get a mutable reference to a DOM element or a value that persists across re-renders.

Here are some common use cases for useRef:

Accessing DOM elements: You can use useRef to get a reference to a DOM element and then manipulate its properties directly. For example, you might want to focus an input field when a component mounts, or scroll to a particular section of the page.

import React, { useRef, useEffect } from 'react';

function MyComponent() {
  const inputRef = useRef(null);

  useEffect(() => {
    inputRef.current.focus();
  }, []);

  return (
    <div>
      <input type="text" ref={inputRef} />
    </div>
  );
}


Storing mutable values: useRef can be used to store mutable values that persist across re-renders, but that don't trigger a re-render when they are updated. This can be useful for things like caching expensive computations, storing event handlers, or managing the state of uncontrolled components.


Timer task:-
---------
In this example, we use useState to manage the state of the seconds variable, which represents the number of seconds that have elapsed. We also create a ref using useRef to store a reference to the setInterval function that we use to increment the seconds variable.

The startTimer function starts the timer by calling setInterval and passing in a function that updates the seconds state variable. We store the setInterval function in the intervalRef so that we can clear it later.

The stopTimer function stops the timer by calling clearInterval and passing in the setInterval function that we stored in the intervalRef.

The resetTimer function resets the timer by setting the seconds variable to 0 and calling clearInterval to stop the timer.

We then render the seconds variable and three buttons that call the startTimer, stopTimer, and resetTimer functions when clicked.
------------------------------------------
import React, { useState, useRef } from 'react';

function Timer() {
  const [seconds, setSeconds] = useState(0);
  const intervalRef = useRef(null);

  function startTimer() {
    intervalRef.current = setInterval(() => {
      setSeconds((seconds) => seconds + 1);
    }, 1000);
  }

  function stopTimer() {
    clearInterval(intervalRef.current);
  }

  function resetTimer() {
    setSeconds(0);
    clearInterval(intervalRef.current);
  }

  return (
    <div>
      <h1>Timer: {seconds}</h1>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
      <button onClick={resetTimer}>Reset</button>
    </div>
  );
}

export default Timer;
------------------------------------------

Formik library:-
-----------------
- For forms validation, we can use the formik library.
https://formik.org/docs/overview
https://formik.org/docs/tutorial#installation

1. Install the formik library:
	npm install formik --save

2. Add a validate method for validation for fields.
	const validate = () => {}

3. Use formik hook for using the form handle.
	useFormik({});

4. For each form input, add the below attributes
	<input
		id="empName"
		name="empName"
		className="form-control"
		onChange={formik.handleChange}
		onBlur={formik.handleBlur}
		value={formik.values.empName}
	  />

5. Show the errors based on the errors Object.
	 {formik.touched.empNo && formik.errors.empNo ? (
				<div className="text-danger">{formik.errors.empNo}</div>
			  ) : null}

Here is the full example of using the formik library.
------------------------------------------
import { useFormik } from "formik";
import { useEffect } from "react";

const validate = (values) => {
  const errors = {};
  if (!values.empName) {
    errors.empName = "Employee name is required";
  } else if (values.empName.length > 15) {
    errors.empName = "Must be less than 15 characters";
  }

  if (!values.empNo) {
    errors.empNo = "EmpNo Required";
  }

  if (!values.bankAccount) {
    errors.bankAccount = "BankAccount Required";
  }

  if (!values.designation) {
    errors.designation = "Designation Required";
  }

  if (!values.doj) {
    errors.doj = "Date of Joining is required";
  }

  if (!values.pan) {
    errors.pan = "PAN is required";
  }

  return errors;
};

function EmployeeForm(props) {
  const formik = useFormik({
    initialValues: {
      empName: "",
      empNo: "",
      bankAccount: "",
      designation: "",
      doj: "",
      pan: "",
    },
    validate,
    onSubmit: (values) => {
      props.onSave(values);
    },
  });

  useEffect(() => {
    if (props.selectedModel) {
      const model = props.selectedModel;
      formik.setValues(model);
    }
  }, []);

  return (
    <div className="border p-4 m-4 rounded shadow">
      <h1>Employee form</h1>
      <form onSubmit={formik.handleSubmit}>
        <div className="m-2">
          <label about="empName">Emp Name</label>
          <input
            id="empName"
            name="empName"
            className="form-control"
            onChange={formik.handleChange}
            onBlur={formik.handleBlur}
            value={formik.values.empName}
          />
          {formik.touched.empName && formik.errors.empName ? (
            <div className="text-danger">{formik.errors.empName}</div>
          ) : null}
        </div>

        <div className="m-2">
          Emp No:
          <input
            id="empNo"
            name="empNo"
            className="form-control"
            onChange={formik.handleChange}
            onBlur={formik.handleBlur}
            value={formik.values.empNo}
          />
          {formik.touched.empNo && formik.errors.empNo ? (
            <div className="text-danger">{formik.errors.empNo}</div>
          ) : null}
        </div>

        <div className="m-2">
          Designation:
          <input
            type="text"
            className="form-control"
            id="designation"
            name="designation"
            onChange={formik.handleChange}
            onBlur={formik.handleBlur}
            value={formik.values.designation}
          />
          {formik.touched.designation && formik.errors.designation ? (
            <div className="text-danger">{formik.errors.designation}</div>
          ) : null}
        </div>

        <div className="m-2">
          Bank Account :
          <input
            type="text"
            className="form-control"
            id="bankAccount"
            name="bankAccount"
            onChange={formik.handleChange}
            onBlur={formik.handleBlur}
            value={formik.values.bankAccount}
          />
          {formik.touched.bankAccount && formik.errors.bankAccount ? (
            <div className="text-danger">{formik.errors.bankAccount}</div>
          ) : null}
        </div>

        <div className="m-2">
          PAN :
          <input
            type="text"
            className="form-control"
            id="pan"
            name="pan"
            onChange={formik.handleChange}
            onBlur={formik.handleBlur}
            value={formik.values.pan}
          />
          {formik.touched.pan && formik.errors.pan ? (
            <div className="text-danger">{formik.errors.pan}</div>
          ) : null}
        </div>

        <div className="m-2">
          DOJ :
          <input
            type="date"
            className="form-control"
            id="doj"
            name="doj"
            onChange={formik.handleChange}
            onBlur={formik.handleBlur}
            value={formik.values.doj}
          />
          {formik.touched.doj && formik.errors.doj ? (
            <div className="text-danger">{formik.errors.doj}</div>
          ) : null}
        </div>

        <div>
          <button type="submit" className="btn btn-primary">
            Save
          </button>
          <button className="ms-2 btn btn-secondary" onClick={props.onCancel}>
            Cancel
          </button>
        </div>
      </form>
    </div>
  );
}

export default EmployeeForm;

------------------------------------------

Formik with useFormik hook
---------------------------

import { useFormik } from "formik";
import { Link, useHistory } from "react-router-dom";
import Loader from "../Loader/Loader";

const validate = (values) => {
  const errors = {};
  if (!values.fullname) {
    errors.fullname = "fullname is required";
  } else if (values.fullname.length > 15) {
    errors.fullname = "Must be less than 15 characters";
  }

  if (!values.username) {
    errors.username = "username Required";
  }

  if (!values.password) {
    errors.password = "password Required";
  }

  return errors;
};

function Registration() {

  const formik = useFormik({
    initialValues: {
      fullname: '',
      username: '',
      password: ''
    },
    validate,
    onSubmit: values => { alert(JSON.stringify(values)) }
  });



  return (
    <div className="w-50 m-auto shadow border p-4 mt-4">
      <h5>Registration</h5>
        <form onSubmit={formik.handleSubmit}>
          <div  className="mt-2">
              Fullname:
              <input className="form-control"
               id="fullname"
               {...formik.getFieldProps('fullname')}
               />
          </div>
          <div>
          {formik.touched.fullname && formik.errors.fullname ? (
            <div className="text-danger">{formik.errors.fullname}</div>
          ) : null}
          </div>

           <div  className="mt-2">
              Username:
              <input  className="form-control"
              id="username"
              {...formik.getFieldProps('username')}
              />
          </div>
          <div>
          {formik.touched.username && formik.errors.username ? (
            <div className="text-danger">{formik.errors.username}</div>
          ) : null}
          </div>

           <div  className="mt-2">
              Password:
              <input  className="form-control"
              id="password"
              {...formik.getFieldProps('password')}
              />
          </div>

          <div>
          {formik.touched.password && formik.errors.password ? (
            <div className="text-danger">{formik.errors.password}</div>
          ) : null}
          </div>

          <div className="mt-2">
              <button className="btn btn-primary">Register</button>
          </div>
        </form>
    </div>
  );
}

export default Registration;



Validations using the Yup library:-

npm install yup --save
----------------------------------

import React from 'react';
import { useFormik } from 'formik';
import * as Yup from 'yup';

const SignupForm = () => {
  const formik = useFormik({
    initialValues: {
      firstName: '',
      lastName: '',
      email: '',
    },
    validationSchema: Yup.object({
      firstName: Yup.string()
        .max(15, 'Must be 15 characters or less')
        .required('Required'),
      lastName: Yup.string()
        .max(20, 'Must be 20 characters or less')
        .required('Required'),
      email: Yup.string().email('Invalid email address').required('Required'),
    }),
    onSubmit: values => {
      alert(JSON.stringify(values, null, 2));
    },
  });
  return (
    <form onSubmit={formik.handleSubmit}>
      <label htmlFor="firstName">First Name</label>
      <input
        id="firstName"
        type="text"
        {...formik.getFieldProps('firstName')}
      />
      {formik.touched.firstName && formik.errors.firstName ? (
        <div>{formik.errors.firstName}</div>
      ) : null}

      <label htmlFor="lastName">Last Name</label>
      <input
        id="lastName"
        type="text"
       {...formik.getFieldProps('lastName')}
      />
      {formik.touched.lastName && formik.errors.lastName ? (
        <div>{formik.errors.lastName}</div>
      ) : null}

      <label htmlFor="email">Email Address</label>
      <input
        id="email"
        type="email"
        {...formik.getFieldProps('email')}
      />
      {formik.touched.email && formik.errors.email ? (
        <div>{formik.errors.email}</div>
      ) : null}

      <button type="submit">Submit</button>
    </form>
  );
};


Formik final approch:-
--------------------
import React from 'react';
import { Formik, Field, Form, ErrorMessage } from 'formik';
import * as Yup from 'yup';

const SignupForm = () => {
  return (
    <Formik
      initialValues={{ firstName: '', lastName: '', email: '' }}
      validationSchema={Yup.object({
        firstName: Yup.string()
          .max(15, 'Must be 15 characters or less')
          .required('Required'),
        lastName: Yup.string()
          .max(20, 'Must be 20 characters or less')
          .required('Required'),
        email: Yup.string().email('Invalid email address').required('Required'),
      })}
      onSubmit={(values, { setSubmitting }) => {
        setTimeout(() => {
          alert(JSON.stringify(values, null, 2));
          setSubmitting(false);
        }, 400);
      }}
    >
      <Form>
        <label htmlFor="firstName">First Name</label>
        <Field name="firstName" type="text" />
        <ErrorMessage name="firstName" />

        <label htmlFor="lastName">Last Name</label>
        <Field name="lastName" type="text" />
        <ErrorMessage name="lastName" />

        <label htmlFor="email">Email Address</label>
        <Field name="email" type="email" />
        <ErrorMessage name="email" />

        <button type="submit">Submit</button>
      </Form>
    </Formik>
  );
};

--------------------------------------
import { EXPENSE_V1_URL } from "../../../utils/Enpoints";

export async function loadExpenseWithAsync(callback) {
  try {
    let promiseData = await fetch(EXPENSE_V1_URL);
    let data = await promiseData.json();
    callback(data);
  } catch (error) {
    //
    alert("Some error occurred")
  }
}

//Edit the data 

Axios:-
------
- Axios is a library for managing the REST API integration.
- Axios has methods for handling the GET, POST, PUT, DELETE and other requests.
- Axios methods returns the Promises.

1. Install the library the project.
npm install axios --save

Import Axios into your component where you'll be making the API calls:

import axios from 'axios';

Create functions to perform the CRUD operations. Here's an example of how you can create functions to fetch data, create new data, update existing data, and delete data using Axios:
javascript
Copy code
const apiUrl = 'http://localhost:3000/api';

// Fetch data
const fetchData = async () => {
  const response = await axios.get(`${apiUrl}/data`);
  return response.data;
};

// Create new data
const createData = async (data) => {
  const response = await axios.post(`${apiUrl}/data`, data);
  return response.data;
};

// Update existing data
const updateData = async (id, data) => {
  const response = await axios.put(`${apiUrl}/data/${id}`, data);
  return response.data;
};

// Delete data
const deleteData = async (id) => {
  const response = await axios.delete(`${apiUrl}/data/${id}`);
  return response.data;
};
In your component, use these functions to perform the desired CRUD operations. Here's an example of how you can use the functions to fetch data and display it in a table:
javascript
Copy code
import { useState, useEffect } from 'react';

const Table = () => {
  const [tableData, setTableData] = useState([]);

  useEffect(() => {
    const fetchData = async () => {
      const data = await fetchData();
      setTableData(data);
    };

    fetchData();
  }, []);

  return (
    <table>
      <thead>
        <tr>
          <th>ID</th>
          <th>Name</th>
          <th>Age</th>
        </tr>
      </thead>
      <tbody>
        {tableData.map((row) => (
          <tr key={row.id}>
            <td>{row.id}</td>
            <td>{row.name}</td>
            <td>{row.age}</td>
          </tr>
        ))}
      </tbody>
    </table>
  );
};
In this example, the useEffect hook is used to fetch the data when the component is mounted. The fetchData function uses the fetchData function we defined earlier to make a GET request to the API and set the state variable with the response data. The Table component then uses the state variable to display the data in a table.

You can use similar techniques to create new data, update existing data, and delete data in your React app using Axios.

--------------------------------
import axios from 'axios'


  function deleteCompany(index) {
    let value = window.confirm("Are you sure you want delete this?");
    if (value) {
      let model = companyModels[index];
      let url = COMPANY_URL + "/" + model.id;
      axios
        .delete(url)
        .then((data) => {
          toast.success("Successfully deleted");
        })
        .catch((error) => toast.error("some error form backend"));

      setCompanyModels((a) => {
        a.splice(index, 1);
        return a.slice();
      });
    }
  }

function loadDataFromServer() {
	axios
	  .get(COMPANY_URL)
	  .then((response) => {
		setCompanyModels(response.data);
		setLoading(false);
	  })
	  .catch((err) => {
		setCompanyModels([]);
		setLoading(false);
	  });
}

function updateData(){
  let compnayPromise = axios.put(
			COMPANY_URL + "/" + selectedCompany.id,
			model
		  );
		  compnayPromise
			.then((data) => {
			  toast.success("successfully updated.");
			})
			.catch((error) => toast.error("some error while update the data"));
}

function saveData(){
	let compnayPromise = axios.post(COMPANY_URL, model);
        compnayPromise
          .then((data) => {
            toast.success("successfully saved.");
          })
          .catch((error) =>
            toast.error("some error while saving the data" + error)
          );
}
--------------------------------
What is Axios interceptor?
- Interceptors will be executed for each request before sending to the server.
- Using interceptor, we can modify the server request like adding new headers.
- The Interceptor can be useful for adding custom headers(X-Client-Key) to the outgoing request, logging the incoming response

- Axios Interceptors is to add the Authorization Header/any token to every request. In our project, we add auth-token header to each request.

https://axios-http.com/docs/interceptors

Axios is a popular HTTP client library that is often used in React applications to make API requests. Axios interceptors are a powerful feature of the library that allow you to intercept and modify requests and responses globally.

Interceptors are functions that you can register globally with Axios using the axios.interceptors property. You can register two types of interceptors: request interceptors and response interceptors.

Request interceptors allow you to modify the request before it is sent to the server. For example, you can add headers, modify the URL, or add authentication tokens. Here is an example of registering a request interceptor:

------------------------------------------------
axios.interceptors.request.use(config => {
  config.headers.Authorization = `Bearer ${getToken()}`
  return config
})
------------------------------------------------

This interceptor adds an Authorization header to every request with a bearer token retrieved from the getToken() function.

Response interceptors allow you to modify the response after it is received from the server. For example, you can handle error responses globally or modify the data before it is passed to the calling code. Here is an example of registering a response interceptor:

------------------------------------------------
axios.interceptors.response.use(response => {
  if (response.status === 401) {
    // handle unauthorized error
  }
  return response
}, error => {
  // handle other errors
  return Promise.reject(error)
})

-----------------------------------------
This interceptor checks the status of the response and handles unauthorized errors globally. The second function handles other errors and returns a rejected promise to propagate the error to the calling code.

Interceptors are a powerful tool that can simplify your code and make it more consistent. By using interceptors, you can handle common tasks like authentication or error handling in a centralized location, instead of duplicating the logic in every API call.


----------------------------------------------------------------
import axios from 'axios' // Add a request interceptor

const API = axios.create();

// Add a request interceptor
API.interceptors.request.use(function (config) {
    // Do something before request is sent
	const token = sessionStorage.getItem("Authorization-key");
	req.headers = {
                'Authorization-key': `Bearer ${token}`
            };
			
    return config;
  }, function (error) {
    // Do something with request error
    return Promise.reject(error);
  });

// Add a response interceptor
API.interceptors.response.use(function (response) {
    // Any status code that lie within the range of 2xx cause this function to trigger
    // Do something with response data
    return response;
  }, function (error) {
    // Any status codes that falls outside the range of 2xx cause this function to trigger
    // Do something with response error
    return Promise.reject(error);
  });
-----------------------------------------------------

JWT:-
-----
JWT, or JSON Web Tokens, are a popular way to securely transmit information between parties. They are often used for authentication and authorization purposes. Here's an example of how a JWT might work in practice:

Let's say you have a user named Alice who wants to log in to a website. Alice sends her login credentials (username and password) to the server. The server verifies her credentials and generates a JWT token for her. This token contains information about Alice, such as her user ID and any permissions she has on the site.

The JWT token is then sent back to Alice's browser, where it is stored as a cookie or in local storage. Whenever Alice makes a request to the server, her browser sends the JWT token along with the request.

The server then verifies the JWT token to make sure it is valid and has not been tampered with. If the token is valid, the server can then use the information contained within it to authorize Alice's request. For example, if Alice is trying to access a protected page on the site, the server can check her permissions in the JWT token to see if she is allowed to access that page.

Overall, JWTs provide a secure and efficient way to transmit information between parties. They are widely used in web development and are supported by many popular programming languages and frameworks.


State management:-
----------------
- Storing the application data is called state management.
- In react we can manage state mainly by 2 ways.
	1. Component state
		- It is applicable only for the particular component.
		- Using the useState hook we can maintain the component data.
	2. Global state.
		- Storing the data at application level is called global state.
		- global state maintenance allows the avoiding of property drilling.

1. Component state management:-
------------------------------
State management is an important concept in React, as it allows you to keep track of the current state of your application and make changes to that state over time. There are several approaches to state management in React, each with its own benefits and trade-offs.

One popular approach is to use React's built-in useState hook. This allows you to define state variables within your functional components and update them using the setState method. Here's an example:


import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  function increment() {
    setCount(count + 1);
  }

  function decrement() {
    setCount(count - 1);
  }

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
    </div>
  );
}
In this example, we define a state variable called count using the useState hook. We initialize it to 0 and provide two functions, increment and decrement, that update the count variable using the setCount method. We then render the current value of count along with two buttons that call the increment and decrement functions when clicked.

Another approach to state management in React is to use a third-party library such as Redux or MobX. These libraries provide more advanced features for managing complex state, such as middleware, asynchronous actions, and time-travel debugging. However, they can also add additional complexity and boilerplate code to your application.

Ultimately, the approach you choose for state management in React will depend on the specific needs of your application. For simple cases, using React's built-in useState hook may be sufficient, while for more complex cases, a third-party library may be necessary.
-----------------------------------------

Props drilling:-
-----------------------
In React, props drilling refers to the process of passing data down the component tree by passing props through multiple levels of components. This can become an issue in larger applications, where components may be nested deeply in the component tree, as it can make it difficult to manage and maintain the flow of data.

Props drilling can be avoided in a few ways:

Context API: Context API allows data to be passed down the component tree without having to pass props through each level of components. The data can be accessed by any component that is a child of the Provider component.

Redux: Redux is a state management library that can be used to manage data in larger applications. It provides a centralized store where all the data is stored and can be accessed by any component.

2. Global state management:-
--------------------------
Global state management in React refers to the management of application-wide state that can be accessed and modified by any component in the application, regardless of its location in the component tree.

Global state can be stored mainly using 2 ways:
1. React Context
2. Redux state

1. React Context:-
-----------------
- React context is used to maintain the global state.
- React context avoids the property drilling.
- The Context API allows you to create a context object that can be used to share state between components. Here's an example:

Steps:-
--------
1. Create the react context.
	export const UserContext = createContext({
		username: '',
		updateLoginStatus: (username) => {}
	})

- Context takes the Object as an argument. We can write the required global state variables in this object.
- For example, we want maintain the logged in user name so add username in the object.

2. Create the ContextProvider object.
- Write the methods and variables are required in the state.
-----------------------------------------------
	export default const UserContextProvider = (props) => {
		const [user, setUser] = useState("");

		function updateLoginStatus(username) {
			setUser(username);
		}
		return (<UserContext.Provider value={{username: user, updateLoginStatus: updateLoginStatus}}>
					{props.children}
				</UserContext.Provider>)
	}
-------------------------------------------------

3. Go to index.js and use the Context provider.
	<UserContextProvider>
		<App />
	</UserContextProvider>

4. Go to any component, get the latest value from the React context using the useContext hook.
	function Header() {
	  const userObj = useContext(UserContext);

	  return (
		<>
		  <h2>{userObj.username}</h2>
		</>
		);
	}

5. If we want update the any state, then call the methods which are available in the context provider.
	function ExpenseChild() {
	  const userObj = useContext(UserContext);

	  return (
		<>
		  <button onClick={() => userObj.updateLoginStatus('Test')}>Login</button>
		</>
		);
	}

-----------------------------------------------
Global state management in React refers to the management of application-wide state that can be accessed and modified by any component in the application, regardless of its location in the component tree.

There are several popular libraries for global state management in React, including Redux, MobX, and Context API. In this answer, we will focus on the Context API, which is built into React and provides a simple way to manage global state.

The Context API allows you to create a context object that can be used to share state between components. Here's an example:

import { createContext, useState } from "react";

export const UserContext = createContext({
    username: "",
    login: (username) => {},
});

export const UserContextProvider = (props) => {
    const [username, setUsername] = useState("");

    function login(username) {
        setUsername(username);
    }
    
    return (
        <UserContext.Provider value={{username,login}}>
            {props.children}
        </UserContext.Provider>
    )
}

In this example, we create a context object called CountContext using the React.createContext method. We define a state variable called count and two functions, increment and decrement, that update the count variable. We then wrap the Counter component in a CountContext.Provider component that passes the count, increment, and decrement values as the context value.

In the DisplayCount component, we use the useContext hook to access the context value and render the current value of count.

By using the Context API, we can share state between the Counter and DisplayCount components without passing props through the component tree. Any component that needs access to the count, increment, and decrement values can simply use the useContext hook to retrieve them from the context.
-----------------------------------------------


Redux:-
------
- Redux is a pattern and library for managing and updating application state, using events called "actions".

- Redux is used to maintain the global state.
- Redux avoids the property drilling.
- For Redux, we can install the redux toolkit.

Redux Toolkit:-
-------------
Redux Toolkit is a popular library for building and managing state in React applications that use Redux. It provides a set of utilities and conventions that make it easier to write Redux code by reducing the amount of boilerplate code you need to write.

One of the key features of Redux Toolkit is its createSlice function, which is a tool for defining Redux reducers. A reducer is a pure function that takes the current state and an action, and returns the new state. With createSlice, you can define a reducer in a simpler, more intuitive way than with the standard Redux createReducer function.

Redux using redux toolkit.
1. Install redux toolkit
npm install @reduxjs/toolkit react-redux

https://redux-toolkit.js.org/introduction/getting-started
https://react-redux.js.org/tutorials/quick-start

Redux has mainly 4 parts.
1. Actions
2. Reducer
3. Store
4. View

Actions:-
-------
An action is a plain JavaScript object that has a type field.
- Action is like an event that describes something that happened in the application.
- The type value should be unique. The type field should be a string that gives this action a descriptive name, like "todos/todoAdded".

----------------------
const addTodoAction = {
  type: 'todos/todoAdded',
  payload: 'Buy milk'
}
----------------------

Reducer:-
--------
- A reducer is a function that receives the current state and an action object, decides how to update the state if necessary, and returns the new state: (state, action) => newState

Reducers must always follow some specific rules:
- They should only calculate the new state value based on the state and action arguments
- They are not allowed to modify the existing state. Instead, they must make immutable updates, by copying the existing state and making changes to the copied values.
- They must not do any asynchronous logic, calculate random values, or cause other "side effects"
------------------------------------------
const initialState = { value: 0 }

function counterReducer(state = initialState, action) {
  // Check to see if the reducer cares about this action
  if (action.type === 'counter/increment') {
    // If so, make a copy of `state`
    return {
      ...state,
      // and update the copy with the new value
      value: state.value + 1
    }
  }
  // otherwise return the existing state unchanged
  return state
}
------------------------------------------
Store:-
------
- All application data will be stored in the Store object.
- The store is created by passing in a reducer, and has a method called getState that returns the current state value


--------------------------------------
import { configureStore } from '@reduxjs/toolkit'

const store = configureStore({ reducer: counterReducer })

console.log(store.getState())
// {value: 0}
--------------------------------------

Dispatch:-
--------
- dispatch method should be used to update the store dynamically.
- dispatch method takes the action as an argument.

------------------------
store.dispatch({ type: 'counter/increment' })
-------------------------

Selectors:-
-----------
- Using selectors, we can get the value from store state value.
- Selectors are functions that know how to extract specific pieces of information from a store state value.

--------------------------------------------
const selectCounterValue = state => state.value

const currentValue = selectCounterValue(store.getState())
console.log(currentValue)
--------------------------------------------

Steps:-
https://redux.js.org/tutorials/essentials/part-2-app-structure

1. Create a Redux Slices file.
A "slice" is a collection of Redux reducer logic and actions for a single feature in your app, typically defined together in a single file.
---------------------------------
import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";

export const fetchUsers = createAsyncThunk('users/fetchUsers', async () => {
  const response = await fetch('https://trinitstechnologies.com/demo/api/v1/user')
  const data = await response.json();
  return data
})

const initialState = {
  username: '',
  isAuthenticated: false,
  users: []
};

export const userSlice = createSlice({
  name: "counter",
  initialState,
  reducers: {
    userData: (state, action) => {
      state.username =  action.payload;
    },
    authenticated: (state, action) => {
      state.isAuthenticated = action.payload;
    },
  },
  extraReducers(builder) {
    builder.addCase(fetchUsers.fulfilled, (state, action) => {
      console.log(action.payload);
      state.users = state.users.concat(action.payload)
      // return action.payload;
    })
  }
});

// Action creators are generated for each case reducer function
export const { userData, authenticated } = userSlice.actions;

export default userSlice.reducer;
-------------------------------------------------

2. Configure the Store.
The Redux store is created using the configureStore function from Redux Toolkit. configureStore requires that we pass in a reducer argument.
--------------------------------
import { configureStore } from '@reduxjs/toolkit'
import counterReducer from '../features/counter/counterSlice'

export default configureStore({
  reducer: {
    counter: counterReducer
  }
})
--------------------------------

3. Providing the Store
----------------------
We always have to call ReactDOM.render(<App />) to tell React to start rendering our root <App> component. In order for our hooks like useSelector to work right, we need to use a component called <Provider> to pass down the Redux store behind the scenes so they can access it.

-------------------------------
import { Provider } from 'react-redux'
import Store from './Store/Store';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <BrowserRouter>
    <Provider store={Store}>
      <App />
  </Provider>,
    </BrowserRouter>
  </React.StrictMode>
);
-------------------------------

4. To update the data to the store, we have to dispatch the action.
- We can dispatch the action to update the data to the store.
---------------------------
import { authenticated } from '../../store/userSlice'
import { useSelector, useDispatch } from 'react-redux'

const username = useSelector((state) => state.user.username);
const isAuthenticated = useSelector((state) => state.user.isAuthenticated);
const dispatch = useDispatch();
dispatch(authenticated(username));
---------------------------


5. To get the latest data from the store, we have to use 'useSelector'
- We can useSelector hook used to get data from store object.
---------------------------
import { useSelector } from 'react-redux'

const username = useSelector((state) => state.user.username);
const isAuthenticated = useSelector((state) => state.user.isAuthenticated);
---------------------------


--------userSlice.js-----------------------------------------------
import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import { API } from "../Hooks/Api";
import { USERS_URL } from "../utils/Endpoints";

export const fetchUsers = createAsyncThunk("users/fetchUsers", async () => {
  const response = API.get(USERS_URL);
  const data = await response.data;
  return data;
});

const initialState = {
  username: "",
  users: [],
};

const userSlice = createSlice({
  name: "user",
  initialState,
  reducers: {
    login: (state, action) => {
      state.username = action.payload;
    },
  },
  extraReducers(builder) {
    builder.addCase(fetchUsers.fulfilled, (state, action) => {
      state.users = [...action.payload];
    });
  },
});

export const { login } = userSlice.actions;

export default userSlice.reducer;
-----------------------------------------


-----Store.js-------------------------
import { configureStore } from "@reduxjs/toolkit";
import userReducer from "./User.slice";

const Store = configureStore({
    reducer: {
        user: userReducer,
    }
})

export default Store;
------------------------------


Both Redux Thunk and Redux Saga are middleware libraries for Redux, which is a popular state management library for JavaScript applications. They are used to handle asynchronous actions, such as fetching data from a server, and to manage complex workflows in Redux.

The main difference between Redux Thunk and Redux Saga is in the way they handle asynchronous actions.

Redux Thunk:-
------------
It is a simpler and more lightweight library that allows you to write asynchronous logic in a simple and familiar way, using plain JavaScript functions that return other functions.
It is easier to learn and understand, and is a good fit for small to medium-sized applications that do not have very complex workflows.
It is best suited for handling simple asynchronous tasks such as making API requests and dispatching actions.

Redux Saga:-
------------
It is a more advanced library that uses ES6 Generators to create a more powerful and flexible approach to handling asynchronous actions.
It is better suited for larger and more complex applications, with more complex workflows and more advanced requirements.
It provides more advanced features like cancelling or retrying failed requests, and provides more control over the flow of actions and side effects.
In summary, Redux Thunk is a simpler and more lightweight solution for handling asynchronous actions in Redux, while Redux Saga is a more advanced and flexible solution for managing complex workflows with advanced requirements.

Handle invalid routes:-
----------------------
- For invalid routes, Add a separate route with path '**'
- This route should be the last route path in the routes files.
- Whenever no routes matches to the given url, then PageNotFound will be displayed.

-------------------------------
<Route path="**">
  <PageNotFound />
</Route>
-------------------------------

How to protect the routes in the React app?
- If the user is not authenticated or not authorized for particular routes, then those routes should not be
visible to the user.
- Add the routes using JSX syntax only if the user is successfully logged in.
-----------------------------------------------
const isAuthenticated = useSelector((state) => state.user.isAuthenticated);
  const classNames = isAuthenticated ? "main-content" : "main-content w-100";

  let protectedContent;
  if (isAuthenticated) {
    protectedContent = (
      <>
        <Route path="/companies">
          <Companies />
        </Route>

        <Route path="/employees">
          <Employees />
        </Route>

        <Route path="/report">
          <Reports />
        </Route>

        <Route path="/settings">
          <Settings />
        </Route>
      </>
    );
  }

  {protectedContent}
-----------------------------------------------
Lazy loading:-
-------------
- Lazy loading means that a component or a part of code must get loaded when it is required. It is also referred to as code splitting and data fetching.
- Each module can be loaded only when it is required.
- React 16.6+, react added React Suspense which performs lazy loading.

---------------------------------------------
import React, { Suspense } from "react";
const Customer = React.lazy(() => import("./Customer.js"));
const Admin = React.lazy(() => import("./Admin.js"));

//Instead of regular import statements, we will use the above approach for lazy loading

export default (props) => {
	if (props.user === "admin") {
		return (
			// fallback component is rendered until our main component is loaded
			<Suspense fallback={<div>Loading</div>}>
				<Admin />
			</Suspense>
		);
	} else if (props.user === "customer") {
		return (
			<Suspense fallback={<div>Loading</div>}>
				<Customer />
			</Suspense>
		);
	} else {
		return <div> Invalid User </div>;
	}
};
---------------------------------------------


Third party libraries:-
React tooltip:-
---------------
- Tooltips help users for displaying the help text.

1. Install the library to the project.
npm install react-tooltip

1. import ReactTooltip from 'react-tooltip';
2. Add data-tip = "your placeholder" to your element
3. Include react-tooltip component
---------------------------------------------------------------
import ReactTooltip from 'react-tooltip';

<h1 id="app-title" style={{ backgroundColor: "#999" }}>
          Hello Tooltip Example
</h1>
<ReactTooltip
        anchorId="app-title"
        place="top"
        content="Hello world! I'm a Tooltip"
      />
---------------------------------------------------------------


React icons:-
-------------
- To display the any icons, we can use react-icons library.

1. Install the library to the project.
npm install react-icons --save

2. Import the icon and use that as a tag.
----------------------------------------
import { FaBeer } from 'react-icons/fa';
<h3> Lets go for a <FaBeer />? </h3>
----------------------------------------

Toast library:-
--------------
- To show the toast messages, we can use the react-toast library.
https://www.npmjs.com/package/react-toastify

1. Add these to the app.js

import { ToastContainer, toast } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

<ToastContainer />

2. Go to the any class where you want to notify, call the below method.
toast.success("Successfully logged in");
toast.error(
        "Error while login process. Check your username and password",
        {
          position: "bottom-left",
          autoClose: 5000,
          hideProgressBar: false,
          closeOnClick: true,
          pauseOnHover: true,
          draggable: true,
          progress: undefined,
          theme: "light",
        }
      );


Node-sass library:-
-----------------
Node-sass is a popular library for Node.js that provides binding for Sass, a CSS preprocessor. It allows developers to write CSS code in a more structured and organized way, with features such as variables, mixins, and nested rules.

When using node-sass with React, developers can import .scss files directly into their React components and use Sass syntax in their styles. This can help make the code more modular and easier to maintain.

To use node-sass with React, you will first need to install it as a dependency using npm:
npm install node-sass

- After installing node-sass you can start using Sass in React. Create a styles folder and inside this folder create test.scss. 

Import this file to the component you are working or index.js. You don't need import the node-sass to the component.

------colors.scss------------------------
$primary-color: #007bff;
$secondary-color: #6c757d;

@mixin button-styles {
  background-color: $primary-color;
  color: white;
  padding: 10px;
  border: none;
  border-radius: 5px;
  cursor: pointer;

  &:hover {
    background-color: $secondary-color;
  }
}

------------------------------


-----------header.scss-----------------------------------
@import './colors.scss';

.my-component {
  h1 {
    color: $primary-color;
  }

  button {
    @include button-styles;
  }
}

header {
  background-color: #61dbfb;
  padding: 25;
  padding: 10px;
  margin: 0;
}
----------------------------------------------
SASS:-
------
- Syntactically Awesome Stylesheet
- Sass is a CSS pre-processor.
- Sass reduces repetition of CSS and therefore saves time.
- Sass lets you use features that do not exist in CSS, like variables, nested rules, mixins, imports, inheritance, built-in functions, and other stuff.

Sass files has the ".scss" file extension.

variables:-
---------
- To reuse the properties
- global indicates that a variable is global, which means that it is accessible on all levels.

$variablename: value;
$myFontSize: 18px;
$primary_1: #a2b9bc;
$primary_2: #b2ad7f;
$primary_3: #878f99;

#container {
  width: $myWidth;
}

h1 {
  $myColor: green !global; //global variable
  color: $myColor;   //local variable
}

Nested Rules:-
-------------
- Sass lets you nest CSS selectors in the same way as HTML.
nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }
  li {
    display: inline-block;
  }
  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}

Sass Importing Files:-
-----------------
@import filename;


Mixins:-
-------
@mixin directive lets you create CSS code that is to be reused throughout the website.

The @include directive is used to include a mixin.

@mixin important-text {
  color: red;
  font-size: 25px;
  font-weight: bold;
  border: 1px solid blue;
}

selector {
  @include mixin-name;
}

@extend:-
--------
- The @extend directive lets you share a set of CSS properties from one selector to another.
- .button-basic  {
  border: none;
  padding: 15px 30px;
  text-align: center;
  font-size: 16px;
  cursor: pointer;
}

.button-report  {
  @extend .button-basic;
  background-color: red;
}
-------------------------------------------


Moment library:-
---------------
Moment is a popular JavaScript library for parsing, validating, manipulating, and formatting dates and times. It provides a simple and intuitive API that allows developers to work with dates and times in a variety of formats and timezones.

react-moment is a lightweight wrapper around Moment that allows you to use Moment as a React component. This can make it easier to work with dates and times in your React project, especially if you need to display them in a specific format or update them dynamically.

When using Moment in a React project, you can install it as a dependency using npm or yarn:
npm install --save moment react-moment

-----------------------------------
import React from 'react';
import moment from 'moment';

function MyComponent() {
  const date = moment('2022-03-27T12:00:00Z');
  const formattedDate = date.format('MMM DD, YYYY');

  return (
    <div>
      <p>The date is: {formattedDate}</p>
    </div>
  );
}

In this example, we are creating a Moment object from a string representing a date and time in ISO 8601 format (2022-03-27T12:00:00Z). We then format the date using the format method and display it in our component.

Moment provides a wide range of formatting options, as well as methods for manipulating and comparing dates and times. It also supports working with timezones and localization. By using Moment in your React project, you can make working with dates and times much easier and more efficient.

			
import React from 'react';
import Moment from 'react-moment';

function MyComponent() {
  return (
    <div>
      <p>The date is: <Moment format="DD/MM/YYYY">2022-03-27T12:00:00Z</Moment></p>
      <p>DOB is: <Moment format="DD/MM/YYYY">{empModel.doj}</Moment></p>
    </div>
  );
}

-----------------------------------
Lifecycle of Components
Each component in React has a lifecycle which you can monitor and manipulate during its three main phases.

Below phases are available:
1. Mounting phase
2. Updating phase
3. Unmounting phase
4. Error handling phase

1. Mounting:-
------------
- Mounting means putting elements into the DOM.
1. constructor(props)
	- Whenever object is created, constructor will be executed.
	- This is the first method called during the creation of a component instance. 
	- It is best places to do the initalization, setup the state variables.

2. static getDerivedStateFromProps(props, state)
	- This method is called before the initial render of a component, and any time new props are passed to the component. 
	- It is used to update the component's state based on the props that were passed.

3. render()
	- This method is required for all React components. It is used to generate the HTML markup for the component based on its current props and state.

4. componentDidMount()
	- This method is called after the initial render of a component. It is used to perform any tasks that require access to the DOM, such as setting up event listeners or fetching data from a server.

2. Updating phase:-
-----------
- A component is updated whenever there is a change in the component's state or props.

1. static getDerivedStateFromProps(nextProps, prevState)
	- Also at updates this method is called. This is the first method that is called when a component gets updated.
	- This method is called when new props are received by the component. It is used to update the component's state based on the new props.

2. shouldComponentUpdate(nextProps, nextState)
	- Returns a Boolean value that specifies whether React should continue with the rendering or not.
	- if it returns false then component will not be updated. Default value is true.
	-  This method is called before a component is updated. It is used to determine whether the component should re-render or not, based on changes to its props or state.

3. render()
	- It is called when a component gets updated, it has to re-render the HTML to the DOM, with the new changes.

4. getSnapshotBeforeUpdate()
	- This method provides the previous state and property value.
	- If the getSnapshotBeforeUpdate() method is present, you should also include the componentDidUpdate() method, otherwise you will get an error.

5. componentDidUpdate(prevProps, prevState)
	- This method is called after the component is updated in the DOM.
	- It is used to perform any tasks that require access to the DOM or the component's state or props, such as updating a chart or triggering an animation.

3. Unmounting:-
-----------
- When a component is removed from the DOM, or unmounting as React likes to call componentWillUnmount().

1. componentWillUnmount()
	- The componentWillUnmount method is called when the component is about to be removed from the DOM.
	-  It is used to clean up any resources that the component has acquired, such as event listeners or timers.

4. Error handling phase:-
--------------------
1. static getDerivedStateFromError(error):-
	- This method is called when a child component throws an error. It is used to update the state of the parent component based on the error.

2. componentDidCatch(error, info):-
	- This method is called after a child component throws an error. It is used to log the error or display an error message to the user.
--------------------------------------------------------------
import { Component } from "react";

export default class TestComponent extends Component {
  constructor(props) {
    super(props);
    this.state = {
      name: "Trinits",
    };
    console.log("constructor");
  }

  static getDerivedStateFromProps(props, state) {
    console.log("getDerivedStateFromProps");
    console.log(props.age);
    return {
      ...state,
      age: props.age,
    };
  }

  render() {
    console.log("render");
    return (
      <div>
        Test component {this.state.name} {this.state.age} {this.state.salary}
      </div>
    );
  }

  componentDidMount() {
    console.log("componentDidMount");
    setTimeout(() => {
      console.log("componentDidMount 1");
      this.setState({
        salary: 5000,
      });
    }, 5000);
  }

  shouldComponentUpdate() {
    console.log("shouldComponentUpdate");
	//return nextState.count !== this.state.count;
    return true;
  }

  getSnapshotBeforeUpdate(props, state) {
    console.log(
      "getSnapshotBeforeUpdate " + state.salary + "" + this.state.salary
    );

    return null;
  }

  componentDidUpdate() {
    console.log("componentDidUpdate" + this.state.salary);
  }

  componentWillUnmount() {
    console.log("componentWillUnmount");
  }
}
-------------------------------------------------

Error boundaries in react:-
--------------------------
Error boundaries are a feature in React that allow developers to catch and handle errors that occur during the rendering of a component tree. Normally, when an error is thrown in a component's render method, it will propagate up the component tree and potentially cause the entire application to crash. Error boundaries provide a way to handle these errors gracefully and display a fallback UI instead of crashing the entire application.

To create an error boundary, you need to define a component that implements either or both of the following methods:

static getDerivedStateFromError(error): This method is called when an error is thrown in a child component. It should return an object that will be used to update the component's state, allowing it to render a fallback UI.

componentDidCatch(error, info): This method is called after an error is thrown in a child component. It is used to log the error or perform other side effects.

Here's an example of an error boundary component:

------------------------------------------
import React from 'react';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render will show the fallback UI.
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    // Log the error to an error reporting service.
    console.error(error, info);
  }

  render() {
    if (this.state.hasError) {
      // Render fallback UI
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
In this example, the ErrorBoundary component has a hasError state property that is set to false initially. If an error is thrown in any of its child components, the getDerivedStateFromError method is called, which updates the hasError state property to true. This causes the component to render a fallback UI instead of its children. The componentDidCatch method is also called to log the error to the console.

To use the error boundary component, you simply need to wrap it around the component tree that you want to protect. For example:

-----------------------------------------
import React from 'react';
import ErrorBoundary from './ErrorBoundary';
import MyComponent from './MyComponent';

function App() {
  return (
    <div>
      <h1>Hello, world!</h1>
      <ErrorBoundary>
        <MyComponent />
      </ErrorBoundary>
    </div>
  );
}

export default App;
----------------------------------
In this example, we wrap the MyComponent component in an ErrorBoundary component. If an error is thrown in MyComponent, the ErrorBoundary will catch it and display a fallback UI instead of crashing the entire application.


import React from 'react';

class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  handleClick() {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    // This line will throw an error if this.props.text is undefined
    const textLength = this.props.text.length;

    return (
      <div>
        <p>Text length: {textLength}</p>
        <p>Count: {this.state.count}</p>
      </div>
    );
  }
}

export default MyComponent;

--------------------------------------
This component expects a text prop, and tries to access its length property to display it in the UI. However, if the text prop is not defined, it will throw an error.


Login integration with backend:-
------------------
Integrating a login page with a backend using axios in a React application involves making an HTTP request to the server to authenticate the user. Here's an example of how you can do this:

Create a login form component that takes the user's email and password as input.

When the user submits the form, send an HTTP POST request to the server with the email and password as parameters.

In the server-side code, validate the email and password and return a response indicating whether the user is authenticated or not.

In the React component, handle the response from the server and either display an error message or redirect the user to a different page.

In this example, the LoginForm component captures the user's email and password in state variables and sends an HTTP POST request to the /login endpoint using the axios library when the form is submitted. If the login is successful, you can handle it in the .then block by setting some state to reflect that the user is authenticated. If the login fails, you can handle it in the .catch block by displaying an error message to the user.

Note that this example assumes that the server-side code is already set up to handle the /login endpoint and return the appropriate response. 
----------------------------------
import React, {
  Component,
  useContext,
  useEffect,
  useRef,
  useState,
} from "react";
import { useDispatch } from "react-redux";
import { Link, useHistory } from "react-router-dom";
import { UserContext } from "../../Context/UserContext";
import { fetchUsers, login } from "../../Store/User.slice";
import { AiFillAmazonCircle } from "react-icons/ai";
import { BsFillBoxFill } from "react-icons/bs";
import { loginApi } from "./Hooks/Api";

export default function Login() {
  //useState
  const usernameRef = useRef();
  let [username, setUsername] = useState("");
  let [password, setPassword] = useState("");
  let [errors, setErrors] = useState({
    username: "",
    password: "",
  });

  const dispatch = useDispatch();

  const history = useHistory();
  // const userObj = useContext(UserContext);
  const userObj = {};

  function handleInput(event) {
    setUsername(event.target.value);
  }

  function handlePassword(event) {
    setPassword(event.target.value);
  }

  useEffect(() => {
    usernameRef.current.focus();
  }, []);

  function handleSubmit(event) {
    event.preventDefault();

    let errorObj = {};
    if (!username || !username.trim()) {
      errorObj.username = "User name is required";
    } else if (username.length < 5) {
      errorObj.username = "User name should be minimum 5 characters";
    }

    if (!password || !password.trim()) {
      errorObj.password = "Password is required";
    } else if (password.length < 5) {
      errorObj.password = "Password should be minimum 5 characters";
    }

    setErrors(errorObj);

    if (Object.keys(errorObj).length > 0) {
      return;
    }

    let payload = {
      username,
      password,
    };
    loginApi(payload, (response) => {
      console.log(response);
      const key = sessionStorage.getItem('SESSION_KEY');
      console.log(key);
      dispatch(login(username));
      dispatch(fetchUsers());
      history.push("/dashboard");
    });
  }

  return (
    <div className="w-50 h-50 mb-4 border p-4 m-4 m-auto">
      <h1 className="text-primary text-center">Login</h1>

      <form autoComplete="false" onSubmit={handleSubmit}>
        <div className="mb-1">
          Username:{" "}
          <input
            type="text"
            className="form-control"
            onChange={handleInput}
            ref={usernameRef}
          />
        </div>
        {errors.username && (
          <small className="text-danger">{errors.username}</small>
        )}
        <div className="mb-1">
          Password:{" "}
          <input
            type="password"
            className="form-control"
            onChange={handlePassword}
          />
        </div>
        {errors.password && (
          <small className="text-danger">{errors.password}</small>
        )}

        <div>
          <button className="btn btn-primary">
            <AiFillAmazonCircle /> Login
          </button>
          <Link to="/registration" className="ms-2 btn btn-secondary">
            <BsFillBoxFill /> Registration
          </Link>
        </div>
      </form>
      <div>
        {errors.invalid && (
          <small className="text-danger">{errors.invalid}</small>
        )}
      </div>
    </div>
  );
}
----------------------------------

Save token to save session storage:-
------------------------
When you authenticate a user in your React application using an API call to a backend, you may receive an authentication token from the server. You can save this token in the session storage of the browser to maintain the user's session across different pages of your application. Here's an example of how you can do this:

When you receive the authentication token from the server, save it to the session storage using the sessionStorage.setItem() method.

To retrieve the token later, use the sessionStorage.getItem() method.

To clear the token from the session storage when the user logs out, use the sessionStorage.removeItem() method.

Send token in interceptor:-
----------------------
When you save a user's authentication token to the session storage in your React application, you can use an Axios interceptor to automatically add the token to the headers of all subsequent API requests. This way, you don't have to manually add the token to each request, and the server can authenticate the user based on the token included in the request headers. Here's an example of how you can do this:

Create a new Axios instance with the create method, and set the Authorization header to the value of the token retrieved from the session storage.

Add an interceptor to the Axios instance that adds the Authorization header to all subsequent API requests.

----------------------------------------
import axios from "axios"; // Add a request interceptor

export const API = axios.create();

// Add a request interceptor
API.interceptors.request.use(
  function (config) {
    console.log('Request interceptor: ');

     // Do something before request is sent
     const token = sessionStorage.getItem("SESSION_KEY");
     config.headers = {
       "Authorization-key": `Bearer ${token}`,
     };

    return config;
  },
  function (error) {
    // Do something with request error
    return Promise.reject(error);
  }
);

// Add a response interceptor
API.interceptors.response.use(
  function (response) {
    // Any status code that lie within the range of 2xx cause this function to trigger
    // Do something with response data
    console.log('Response interceptor: ')
    return response;
  },
  function (error) {
    // Any status codes that falls outside the range of 2xx cause this function to trigger
    // Do something with response error
    return Promise.reject(error);
  }
);
----------------------------------------

Pagination in React:-
--------------------
Pagination can be handled in 2 ways.
1. Server side pagination
2. Client side pagination 


1. Server side pagination:-
--------------------------
In server-side pagination, the pagination logic is implemented on the server-side rather than on the client-side. This can be useful when working with large datasets, as it allows you to only retrieve the data that is needed for the current page, rather than loading the entire dataset into the client's browser.

Here's an example of how you can integrate server-side pagination with a React front-end:

Create a server-side endpoint that accepts a page number and page size as parameters, and returns a subset of the data based on these parameters.

Create a React component that fetches the data from the server-side endpoint using a library such as axios.

Add state to the component to keep track of the current page number and page size.

When the component mounts, fetch the initial set of data from the server-side endpoint using the current page number and page size.

Render the data, along with buttons or links to navigate between pages.

Add click handlers to the pagination buttons to update the current page state and fetch the corresponding data from the server-side endpoint.

In this example, the ItemList component fetches data from a server-side endpoint using the axios library. The useEffect hook is used to fetch data whenever the current page number or page size changes. The goToPage function is used to update the current page state when a pagination button is clicked, and the fetchItems function is used to fetch the corresponding data from the server-side endpoint. Finally, the data is rendered as a list, along with pagination buttons for navigating between pages.
---------------------
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function ItemList() {
  const [items, setItems] = useState([]);
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(10);

  useEffect(() => {
    fetchItems();
  }, [currentPage, pageSize]);

  function fetchItems() {
    axios.get(`/items?page=${currentPage}&pageSize=${pageSize}`)
      .then(response => setItems(response.data));
  }

  function goToPage(pageNumber) {
    setCurrentPage(pageNumber);
  }

  return (
    <div>
      <ul>
        {items.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
      <div>
        <button onClick={() => goToPage(currentPage - 1)} disabled={currentPage === 1}>
          Previous
        </button>
        <button onClick={() => goToPage(currentPage + 1)} disabled={items.length < pageSize}>
          Next
        </button>
      </div>
    </div>
  );
}
---------------------

2. Client side pagination :-
---------------------------
Pagination is a common user interface pattern used to divide large sets of data into smaller, more manageable chunks. In React, pagination can be implemented by dividing a list of items into pages and displaying a subset of items at a time.

Here's an example of how you can implement pagination in React:

Create a component to display a list of items. This component should accept a list of items and a page size as props.

Calculate the total number of pages based on the length of the item list and the page size.

Add state to the component to keep track of the current page number.

Create a function to slice the list of items based on the current page number and page size.

Render the sliced list of items, along with buttons or links to navigate between pages.

Add click handlers to the pagination buttons to update the current page state and re-render the component with the updated list of items.

In the below example, the ItemList component accepts an array of items and a page size as props. The useState hook is used to keep track of the current page number. The totalPages, startIndex, endIndex, and visibleItems variables are calculated based on the current page number and page size. The goToPage function is used to update the current page state when a pagination button is clicked. Finally, the visibleItems array is rendered as a list, along with pagination buttons for each page.
---------------------
import React, { useState } from 'react';

function ItemList({ items, pageSize }) {
  const [currentPage, setCurrentPage] = useState(1);

  const totalPages = Math.ceil(items.length / pageSize);
  const startIndex = (currentPage - 1) * pageSize;
  const endIndex = startIndex + pageSize;

  const visibleItems = items.slice(startIndex, endIndex);

  function goToPage(pageNumber) {
    setCurrentPage(pageNumber);
  }

  return (
    <div>
      <ul>
        {visibleItems.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
      <div>
        {Array.from({ length: totalPages }, (_, i) => i + 1).map(pageNumber => (
          <button
            key={pageNumber}
            onClick={() => goToPage(pageNumber)}
            disabled={pageNumber === currentPage}
          >
            {pageNumber}
          </button>
        ))}
      </div>
    </div>
  );
}
---------------------

Hooks:-
------
React hooks are a new feature introduced in React 16.8 (2019) that allows developers to use state and other React features without writing a class component. Hooks are functions that let you "hook into" React state and lifecycle features from functional components.

Hooks allow developers to reuse stateful logic, making it easier to share and manage stateful logic between components. Some of the commonly used hooks are:

1. useState() - Allows functional components to manage state.
2. useEffect() - Runs a side-effect when a component is mounted or updated.
3. useContext() - Allows functional components to use a context that has been created outside of the component.
4. useReducer() - Allows for more complex state management.
5. useMemo() - Memoizes a function so that it only recomputes when the inputs change.
6. useCallback() - Memoizes a function so that it only changes when its dependencies change.
7. useRef

React Hook rules:-
----------------
React hooks are a feature in React that allow you to use state and other React features in functional components, which were previously only available in class components. Here are some rules to keep in mind when using React hooks:

Only call hooks at the top level: React hooks should only be called at the top level of functional components or custom hooks. They should not be called inside loops, conditions, or nested functions.

Only call hooks from React function components: Hooks should only be called from within function components or custom hooks. They should not be called from regular JavaScript functions, event handlers, or lifecycle methods.

Use the correct hook: React provides a variety of hooks for different purposes, such as useState(), useEffect(), useContext(), and useRef(). Make sure to use the appropriate hook for the task you are trying to accomplish.

Use the same order for hooks: When using multiple hooks in a single component, make sure to use them in the same order on every render. This ensures that the React component always renders in a consistent way.

Use hooks conditionally: Hooks should only be used conditionally, such as inside an if statement or a switch statement. This ensures that hooks are only called when needed, and avoids unnecessary performance issues.

Don't use hooks inside loops: Hooks should not be called inside loops, as this can cause unnecessary re-renders and can lead to performance issues.

Don't mutate state directly: State should never be mutated directly using hooks like useState(). Instead, use the function provided by the hook to update the state.


1.useState()
------------
- useState is a Hook, We call it inside a function component to add some local state to it.
- React will preserve this state between re-renders. useState returns a pair: the current state value and a function that lets you update it.
- You can call setFunction from an event handler or somewhere else.

- useState function will take the default value as argument.
import { useState } from "react";

export default function DemoChild(props) {
  const [count, setCount] = useState(10);


  console.log("DemoChild render");
  const increment = () => {
    setCount(count + 1);
  }

  return (
    <div className="m-4 border">
      <h1>Child Component</h1>
      <h2>Count: {count}</h2>
      <button className="btn btn-success" onClick={increment}>Increment</button>
    </div>
  )
}

2. useEffect()
--------------
- data fetching, subscriptions, or manually changing the DOM from React components before. We call these operations “side effects”

The useEffect() hook takes two arguments: a function and an optional array of dependencies. The function is the effect that will be executed when the component mounts, updates, or unmounts. The dependencies are an array of variables that the effect depends on. If any of these variables change, the effect will be re-executed.

-  useEffect(() => {})
	- without any second argument, useEffect will run for every react modifications.
- useEffect(() => {}, [])
	- useEffect method will be executed only for first time when react executed this component.
- useEffect(() => {}, [count])
	- When array is added with external decencies, useEffect method will be executed for each modification of count variable.
--------------------------

//Runs for every change for this component.
useEffect(() => {
  document.title = `You clicked ${count} times`;
});


//Runs for only time when component is gets initialized.
useEffect(() => {
  document.title = `You clicked ${count} times`;
}, []);


//Run only on count variable changes.
useEffect(() => {
  document.title = `You clicked ${count} times`;
}, [count]); // Only re-run the effect if count changes
----------------------------

React life cycle methods in Function component:-
-------------------------
1. componentDidMount()
	- Execute for the first time.
	- in function component, if we are writing the useEffect(() => {}, []) with empty array as argument, then this method will be executing for only first time.
----------------------------------
	useEffect(() => {
	}, [])
----------------------------------
2. componentDidUpdate()
	- Execute for the each change in the UI.
	- in function component, if we are writing the useEffect(() => {}) without second argument, then this method will be executing for each change.
----------------------------------
	useEffect(() => {
	})
----------------------------------
3. componentWillUnmount()
	- Execute only one time before destroying the component.
	- Inside the useEffect() method, return a method which will be executing automatically before unmounting the component.
----------------------------------
	useEffect(() => {

		return () =>{
			console.log('unmount method');
		}
	})


import { useEffect, useState } from "react";
import Component1 from "../Login/Component1";

export default function DemoChild(props) {
  const [count, setCount] = useState(10);
  const [data, setData] = useState([]);

  console.log("DemoChild render");
  const increment = () => {
    setCount(count + 1);
  }

  function loadApiData() {
    fetch("https://jsonplaceholder.typicode.com/todos/"+ count)
      .then((response) => response.json())
      .then((json) => setData(json));
  }

  useEffect(() => {

    const intervalObj = setInterval(() => {
      console.log("setInterval");
    }, 2000);

    console.log("useEffect");
    loadApiData();

    return () => {
      console.log("useEffect cleanup");
      clearInterval(intervalObj);
    } //componenwillunmount

  }, [count]);
  

  return (
    <div className="m-4 border">
      <h1>Child Component</h1>
      <h2>Count: {count}</h2>
      <button className="btn btn-success" onClick={increment}>Increment</button>

      <Component1 />
    </div>
  )
}


3. useContext()
--------------
useContext Hook to manage state globally.
using useContext, component can fetch the global state values.
const user = useContext(UserContext);

useContext() is a React hook that allows functional components to access a context object that has been created outside of the component hierarchy. Context is a way to share data between components without having to pass the data down through each level of the component tree explicitly as props.

To use useContext(), we first create a context object using the React.createContext() method. Then, we can provide a value to the context using a Context.Provider component. Finally, we can access the context value in a child component using the useContext() hook.

4. useRef()
-----------
useRef() is a React hook that returns a mutable ref object. A ref is a way to store a value that persists between renders and is not part of the component state. Unlike state, changes to a ref do not trigger a re-render of the component.

useRef Hook allows you to persist values between renders.
It can be used to store a mutable value that does not cause a re-render when updated.
It can be used to access a DOM element directly.
useRef() only returns one item. It returns an Object called current.
const count = useRef(0);
<h1>Render Count: {count.current}</h1>


5. useReducer()
----------------
The useReducer Hook is similar to the useState Hook.
It allows for custom state logic.
It can be used to access a DOM element directly.
If you find yourself keeping track of multiple pieces of state that rely on complex logic, useReducer may be useful.
The useReducer Hook returns the current stateand a dispatchmethod.
const [todos, dispatch] = useReducer(reducer, initialTodos);
The useReducer Hook is similar to the useState Hook.
It allows for custom state logic.
It can be used to access a DOM element directly.
If you find yourself keeping track of multiple pieces of state that rely on complex logic, useReducer may be useful.
The useReducer Hook returns the current stateand a dispatchmethod.
const [todos, dispatch] = useReducer(reducer, initialTodos);
---------------------------------
// import './Dashboard.css';
import { useReducer, useState } from "react";
import classes from "./Dashboard.module.css";

const initialState = [{
  id: 1,
  data: 'SS-1'
}];

const reducer =  (state, action) => {
  switch (action.type) {

  case "Add": {
    console.log(state);
    return [...state, action.payload]
  }
  case "Del": {
    console.log(state);
    return state.filter(todo => todo.id !== action.payload.id);
  }

  default:
    return state
  }
}

function Dashboard() {
  const [todos, dispatch] = useReducer(reducer, initialState);

  function handleAdd() {
    dispatch({type: "Add", payload: {id: Math.random(), data: "SS-2"}})
  }
  return (
    <div className="w-50 m-4 p-4 border shadow m-auto">
        <h1>Dashboard {todos.length}</h1>
        <button onClick={handleAdd}>Add</button>

        {
          todos.map(todo => {
            return <div key={todo.id + Math.random()}>{todo.data}
            <button onClick={() => {dispatch({type: "Del", payload: todo})}}>Delete</button></div>
          })
        }
    </div>
  );
}

export default Dashboard;


import { useReducer, useState } from "react";

const initialState = [];

const reducer = (state, action) => {
  switch(action.type) {
    case "ADD_NUM": {
      let newNum = (Math.random() * 1000).toFixed(0);
     return [...state, newNum];
    }
    case "DELETE_NUM": {
      let index = action.payload;
      let newData = [...state];
      newData.splice(index, 1);
      return newData;
    }
    default: {
      console.log("Invalid action type");
      return state;
    }
  }
}


export default function DemoChild(props) {
  // const [data, setData] = useState([]);
  const [data, dispatch] = useReducer(reducer, initialState);

  function addNum() {
    dispatch({type: "ADD_NUM"})
  }

  function handleDelete(index) {
    dispatch({type: "DELETE_NUM", payload: index})
  }

  return (
    <div className="m-4 border">
      <h1>Child Component ({data.length})</h1>
      <button className="btn btn-success" onClick={addNum}>Add num</button>

      {
        data.map((num, index) => {
          return <div className="p-2 border" key={index}>{num}
            <button className="ms-2 btn btn-outline-danger" onClick={() => handleDelete(index)}>Delete</button>
          </div>
        })
      }
    </div>
  )
}

---------------------------------

6. useCallback()
----------------
The React useCallback Hook returns a memoized callback function.
This allows us to isolate resource intensive functions so that they will not automatically run on every render.
The useCallback Hook only runs when one of its dependencies update. This can improve performance.
If you find yourself keeping track of multiple pieces of state that rely on complex logic, useReducer may be useful.

The useCallback and useMemo Hooks are similar. The main difference is that useMemo returns a memoized value and useCallback returns a memoized function. You can learn more about useMemo in the useMemo


The React useCallback Hook returns a memoized callback function.
This allows us to isolate resource intensive functions so that they will not automatically run on every render.
The useCallback Hook only runs when one of its dependencies update. This can improve performance.

The useCallback and useMemo Hooks are similar. The main difference is that useMemo returns a memoized value and useCallback returns a memoized function. You can learn more about useMemo in the useMemo

- Every time a component re-renders, its functions get recreated. Because of this, the addTodo function has actually changed.

--------------------------------------------------
// import './Dashboard.css';
import { useCallback, useMemo, useReducer, useState } from "react";
import classes from "./Dashboard.module.css";
import Todos from "./Todo";

function Dashboard() {
  const [count, setCount] = useState(0);
  const [todos, setTodos] = useState([]);

  const increment = () => {
    setCount((c) => c + 1);
  };
  
  const addTodo = useCallback(
    () => {
      setTodos((t) => [...todos, "New Todo"]);
    },
    [todos],
  )


  return (
    <>
      <Todos todos={todos} addTodo={addTodo} />
      <hr />
      <div>
        Count: {count}
        <button onClick={increment}>+</button>
      </div>
    </>
  );
}

export default Dashboard;
--------------------------------------------------

7. useMemo()
-----------
if we use the useMemo() Hook, we can avoid component re-rendering if the inputs are the same and save the result in the cache. 

const cachedValue = useMemo(() => multiply(x, y), [x, y])
if we use the useMemo() Hook, we can avoid component re-rendering if the inputs are the same and save the result in the cache. const cachedValue = useMemo(() => multiply(x, y), [x, y])

--------------------------------------
// import './Dashboard.css';
import { useMemo, useReducer, useState } from "react";
import classes from "./Dashboard.module.css";
import Todos from "./Todo";
const calcTotal = (num) => {
  console.log("Calculating...");
  for (let i = 0; i < 1000; i++) {
    num += 1;
  }
  return num;
};

function Dashboard() {
  const [count, setCount] = useState(0);
  const [todos, setTodos] = useState(["todo 1", "todo 2"]);
  const total = useMemo(() => calcTotal(count), [count]);

  const increment = () => {
    setCount((c) => c + 1);
  };

  return (
    <>
      <Todos todos={todos} />
      <button onClick={() => setTodos([...todos, "Test"])}>Add Todo</button>
      <hr />
      <div>
        Count: {count}
        <button onClick={increment}>+</button>
      </div>
    </>
  );
}

export default Dashboard;
---------------------------------

Custom hooks:-
------------
- Hooks are reusable functions.
- Writing our hooks are called custom hooks.
- If any component logic is common in multiple places, then we can write the custom hooks.
- Custom Hooks start with "use". Example: useApi.
- Custom hooks follow a naming convention of use followed by a descriptive name, such as useLocalStorage or useFetch. They use built-in React hooks and/or other custom hooks to encapsulate reusable logic, and can return any values that are needed by the components that use them.

-------------------------------------------------
import { useState, useEffect } from 'react';

function useFetchData(url) {
  const [data, setData] = useState(null);

  useEffect(() => {
    async function fetchData() {
      const response = await fetch(url);
      const json = await response.json();
      setData(json);
    }
    fetchData();
  }, [url]);

  return data;
}
-------------------------------------------------

--------------------------------------------
import { useFetchData } from './useFetchData';

function MyComponent() {
  const data = useFetchData('https://api.example.com/data');
  return (
    <div>
      {data && <pre>{JSON.stringify(data, null, 2)}</pre>}
    </div>
  );
}
-----------------------------------------

Higher Order Component (HOC):-
----------------------------
A Higher Order Component (HOC) is a design pattern in React that allows you to reuse component logic across multiple components. HOCs are functions that take a component as an argument and return a new component with enhanced functionality. The enhanced component can then be used in place of the original component.

- HOCs are a function that takes a component as an argument and returns a new component with additional functionality.
- HOCs are a way to reuse logic across multiple components, without having to repeat code.
- HOCs can be used to add functionality to a component, such as passing down props, adding state, or handling errors.
- Higher Order Components are a powerful feature of React that allows you to reuse component logic across multiple components, without having to repeat code.

-------------------------
import React, { useState, useEffect } from 'react';

function withDataAndLoader(Component) {
  return function WithLoader(props) {
    const [data, setData] = useState(null);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
      async function fetchData() {
        console.log('Fetching data from ' + JSON.stringify(props));
        const response = await fetch(props.url);
        const data = await response.json();
        setData(data);
        setIsLoading(false);
      }

      fetchData();
    }, [props.url]);

    if (isLoading) {
      return <div>Loading...</div>;
    }

    return <Component {...props} data={data} />;
  };
}

export default withDataAndLoader;



// Usage:
import React from 'react';
import withLoader from './withLoader';

function MyComponent({ data }) {
  return (
    <div>
      <h1>{data.title}</h1>
      <p>{data.body}</p>
    </div>
  );
}

export default withDataAndLoader(MyComponent);
-------------------------

Build:-
------
- Once project is completed, we have to deliver the project to the customers. For that we have to build our project.
run the below command to build the application.
	npm run build

- It will generate the build folder. we can deploy this build folder.

In React, the build process is the process of converting the application's source code into a format that can be executed by a web browser. This process involves several steps, including compiling the application's JavaScript code, bundling the code into a single file, optimizing the file for performance, and creating any necessary static assets (such as CSS files and images).

To build a React application, you can use the npm run build command. This command will run the build script defined in the application's package.json file, which typically uses a tool such as Webpack or Babel to compile and bundle the application's code.

During the build process, the application's code is transformed and optimized for production use. This includes removing any debug code, minifying and compressing the JavaScript, and concatenating and optimizing CSS files.

Once the build process is complete, the resulting files can be deployed to a web server and served to users. The optimized code and assets produced by the build process help to ensure that the application loads quickly and performs well, providing a better user experience.

It's important to note that the build process should be run before deploying the application to a production environment. This ensures that the application's code is optimized and ready for production use.

In the package.json, add the "homepage" property.
https://create-react-app.dev/docs/deployment/


----------------------package.json---------
  "homepage": "https://trinitstechnologies.com/demo/payroll",
--------------------------

Note:- Use the hash router instead of browser router.
---------------------------
root.render(
  <React.StrictMode>
    <HashRouter>
    <Provider store={Store}>
      <App />
  </Provider>,
    </HashRouter>
  </React.StrictMode>
);
---------------------------
https://github.com/brillout/awesome-react-components#table
https://technostacks.com/blog/react-component-libraries/

Deployment:-
----------
Deploying the build to the server from where customers can access the project as URL.

Deployment refers to the process of making a software application or system available for use. It involves taking the application or system that has been developed, and making it available on a server or other platform so that it can be accessed by users.

Deployment involves a series of steps, such as preparing the application for deployment, configuring the deployment environment, and installing the application onto the deployment platform. Once the application is deployed, it can be accessed by users and used to perform the functions for which it was designed.

Deployment is an important aspect of software development, as it enables developers to share their work with others and make it available for use. It also allows for updates and improvements to be made to the application over time, ensuring that it remains relevant and effective in meeting the needs of its users.

To deploy a React project, you have a few different options depending on your specific needs and preferences. Here are some common approaches:

Deploy to a static hosting service:
There are many static hosting services available, such as Netlify, Vercel, and GitHub Pages. To deploy your React project to a static hosting service, you need to build your application using the "npm run build" command, which will create a production-ready build of your app. Once the build is complete, you can simply upload the generated files to the hosting service.

Deploy to a cloud hosting service:
You can also deploy your React project to a cloud hosting service, such as AWS or Google Cloud Platform. These services require a bit more setup and configuration than static hosting services, but they can offer more flexibility and scalability. You will need to create an instance, set up a web server, and configure the server to serve your React app.

Deployment process are 2 types:-
1. Manual deployment:-
---------------------
Manual deployment refers to the process of deploying a software application or system by manually carrying out each step of the deployment process. This typically involves a series of manual tasks, such as configuring the deployment environment, installing the necessary software components, and uploading the application files to the deployment platform.

Manual deployment can be time-consuming and prone to errors, as each step must be carried out carefully and in the correct order. However, it can be useful for smaller applications or when deploying to a simple infrastructure that does not require complex automation or orchestration.

2. Automatic deployment:-
-----------------------
Automatic deployment, also known as automated deployment, refers to the process of deploying a software application or system using automated tools and scripts. This approach aims to reduce manual intervention and streamline the deployment process, making it faster, more efficient, and less prone to errors.

Automated deployment typically involves the use of continuous integration and continuous delivery (CI/CD) pipelines. These pipelines automate the building, testing, and deployment of the application, allowing changes to be pushed from development to production quickly and reliably.

There are many benefits to using automated deployment. It allows for more frequent and predictable releases, reduces the risk of human error, and enables faster time-to-market for new features and improvements. It also facilitates collaboration between development and operations teams, as it encourages regular communication and coordination between the two groups.

CICD pipeline.:-
-----
Continuous Integration and Continuous Development.

A CI/CD (Continuous Integration/Continuous Delivery) pipeline is a series of automated steps that are used to build, test, and deploy a software application or system. The pipeline is designed to automate the process of delivering code changes from development to production, in a reliable and efficient way.

The CI/CD pipeline typically consists of several stages, including:

Source code management: This stage involves managing the source code for the application, typically using a version control system like Git.

Continuous integration: This stage involves building the application and running automated tests to ensure that it meets quality standards. Developers can make code changes and commit them to the source code repository, and the pipeline will automatically trigger a build and test cycle.

Continuous delivery: This stage involves deploying the application to a staging environment for further testing and validation. This stage can include additional automated testing, such as load testing and security testing, to ensure that the application is ready for production.

Continuous deployment: This stage involves deploying the application to the production environment, typically using automated tools and scripts. This stage can include additional steps to ensure that the deployment is safe and reliable, such as rolling updates and automated rollback in case of errors.

JENKINS:-
--------
- > build 
	npm run build.

Jenkins is an open-source automation server that helps to automate the building, testing, and deployment of software applications. It is widely used in software development to enable continuous integration and continuous delivery (CI/CD) pipelines.

Jenkins allows developers to define a series of automated steps that are used to build, test, and deploy their applications. These steps can be triggered automatically by events such as code changes or can be scheduled to run at specific intervals.

Some of the key features of Jenkins include:

Integration with version control systems: Jenkins can integrate with popular version control systems such as Git, SVN, and Mercurial to automatically trigger builds and tests when code changes are made.

- After build is done in Jenkins, copy the build to Server automatically.

